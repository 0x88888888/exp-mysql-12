=== added file 'ch14.txt'
--- ch14.txt	1970-01-01 00:00:00 +0000
+++ ch14.txt	2012-09-16 03:49:57 +0000
@@ -0,0 +1,113 @@
+mysql> source ./t/ch12.test
++------------+------------+------+-----------+
+| first_name | last_name  | sex  | id        |
++------------+------------+------+-----------+
+| John       | Smith      | M    | 333445555 |
+| William    | Walters    | M    | 123763153 |
+| Alicia     | St.Cruz    | F    | 333444444 |
+| Goy        | Hong       | F    | 921312388 |
+| Rajesh     | Kardakarna | M    | 800122337 |
+| Monty      | Smythe     | M    | 820123637 |
+| Richard    | Jones      | M    | 830132335 |
+| Edward     | Engles     | M    | 333445665 |
+| Beware     | Borg       | F    | 123654321 |
+| Wilma      | Maxima     | F    | 123456789 |
++------------+------------+------+-----------+
+10 rows in set (0.00 sec)
+
++-----------+
+| id        |
++-----------+
+| 333445555 |
+| 123763153 |
+| 333444444 |
+| 921312388 |
+| 800122337 |
+| 820123637 |
+| 830132335 |
+| 333445665 |
+| 123654321 |
+| 123456789 |
++-----------+
+10 rows in set (0.00 sec)
+
++-----------------+
+| dir_name        |
++-----------------+
+| Development     |
+| Human Resources |
+| Management      |
++-----------------+
+3 rows in set (0.00 sec)
+
++-----------+-----------------+
+| id        | dir_name        |
++-----------+-----------------+
+| 123763153 | Human Resources |
+| 921312388 | Human Resources |
+| 333445555 | Management      |
+| 123654321 | Management      |
+| 800122337 | Development     |
+| 820123637 | Development     |
+| 830132335 | Development     |
+| 333445665 | Development     |
+| 123456789 | Development     |
++-----------+-----------------+
+9 rows in set (0.00 sec)
+
++-----------+-----------------+
+| id        | dir_name        |
++-----------+-----------------+
+| 123763153 | Human Resources |
+| 921312388 | Human Resources |
+| 333445555 | Management      |
+| 123654321 | Management      |
+| 800122337 | Development     |
+| 820123637 | Development     |
+| 830132335 | Development     |
+| 333445665 | Development     |
+| 123456789 | Development     |
++-----------+-----------------+
+9 rows in set (0.00 sec)
+
++-----------+------------+----------+-----------+------+--------+-----------+
+| id        | first_name | mid_name | last_name | sex  | salary | mgr_id    |
++-----------+------------+----------+-----------+------+--------+-----------+
+| 123456789 | Wilma      | N        | Maxima    | F    |  43000 | 333445555 |
++-----------+------------+----------+-----------+------+--------+-----------+
+1 row in set (0.00 sec)
+
++------------+------------+
+| first_name | last_name  |
++------------+------------+
+| Rajesh     | Kardakarna |
+| Monty      | Smythe     |
+| Richard    | Jones      |
+| Edward     | Engles     |
+| Wilma      | Maxima     |
++------------+------------+
+5 rows in set (0.00 sec)
+
++----------+-----------------+-------------+----------+----------+
+| dir_code | dir_name        | dir_head_id | dir_code | building |
++----------+-----------------+-------------+----------+----------+
+| M00      | Management      | 333444444   | M00      | 1000     |
+| N01      | Human Resources | 123654321   | N01      | 1453     |
+| N41      | Development     | 333445555   | N41      | 1300     |
+| N41      | Development     | 333445555   | N41      | 1301     |
+| N41      | Development     | 333445555   | N41      | 1305     |
++----------+-----------------+-------------+----------+----------+
+5 rows in set (0.00 sec)
+
++----------+-----------------+----------+-------------+
+| dir_code | dir_name        | building | dir_head_id |
++----------+-----------------+----------+-------------+
+| M00      | Management      | 1000     | 333444444   |
+| N01      | Human Resources | 1453     | 123654321   |
+| N41      | Development     | 1300     | 333445555   |
+| N41      | Development     | 1301     | 333445555   |
+| N41      | Development     | 1305     | 333445555   |
++----------+-----------------+----------+-------------+
+5 rows in set (0.00 sec)
+
+Query OK, 4 rows affected (0.00 sec)

=== added file 'mysql-test/include/ch14.sql'
--- mysql-test/include/ch14.sql	1970-01-01 00:00:00 +0000
+++ mysql-test/include/ch14.sql	2012-09-15 19:21:48 +0000
@@ -0,0 +1,74 @@
+# Source on localhost: ... connected.
+# Exporting metadata from expert_mysql
+DROP DATABASE IF EXISTS expert_mysql;
+CREATE DATABASE expert_mysql;
+USE expert_mysql;
+# TABLE: expert_mysql.building
+CREATE TABLE `building` (
+  `dir_code` char(4) NOT NULL,
+  `building` char(6) NOT NULL
+) ENGINE=MyISAM DEFAULT CHARSET=latin1;
+# TABLE: expert_mysql.directorate
+CREATE TABLE `directorate` (
+  `dir_code` char(4) NOT NULL,
+  `dir_name` char(30) DEFAULT NULL,
+  `dir_head_id` char(9) DEFAULT NULL,
+  PRIMARY KEY (`dir_code`)
+) ENGINE=MyISAM DEFAULT CHARSET=latin1;
+# TABLE: expert_mysql.staff
+CREATE TABLE `staff` (
+  `id` char(9) NOT NULL,
+  `first_name` char(20) DEFAULT NULL,
+  `mid_name` char(20) DEFAULT NULL,
+  `last_name` char(30) DEFAULT NULL,
+  `sex` char(1) DEFAULT NULL,
+  `salary` int(11) DEFAULT NULL,
+  `mgr_id` char(9) DEFAULT NULL,
+  PRIMARY KEY (`id`)
+) ENGINE=MyISAM DEFAULT CHARSET=latin1;
+# TABLE: expert_mysql.tasking
+CREATE TABLE `tasking` (
+  `id` char(9) NOT NULL,
+  `project_number` char(9) NOT NULL,
+  `hours_worked` double DEFAULT NULL
+) ENGINE=MyISAM DEFAULT CHARSET=latin1;
+#...done.
+USE expert_mysql;
+# Exporting data from expert_mysql
+# Data for table expert_mysql.building: 
+INSERT INTO expert_mysql.building VALUES ('N41', '1300');
+INSERT INTO expert_mysql.building VALUES ('N01', '1453');
+INSERT INTO expert_mysql.building VALUES ('M00', '1000');
+INSERT INTO expert_mysql.building VALUES ('N41', '1301');
+INSERT INTO expert_mysql.building VALUES ('N41', '1305');
+# Data for table expert_mysql.directorate: 
+INSERT INTO expert_mysql.directorate VALUES ('N41', 'Development', '333445555');
+INSERT INTO expert_mysql.directorate VALUES ('N01', 'Human Resources', '123654321');
+INSERT INTO expert_mysql.directorate VALUES ('M00', 'Management', '333444444');
+# Data for table expert_mysql.staff: 
+INSERT INTO expert_mysql.staff VALUES ('333445555', 'John', 'Q', 'Smith', 'M', 30000, '333444444');
+INSERT INTO expert_mysql.staff VALUES ('123763153', 'William', 'E', 'Walters', 'M', 25000, '123654321');
+INSERT INTO expert_mysql.staff VALUES ('333444444', 'Alicia', 'F', 'St.Cruz', 'F', 25000, 'None');
+INSERT INTO expert_mysql.staff VALUES ('921312388', 'Goy', 'X', 'Hong', 'F', 40000, '123654321');
+INSERT INTO expert_mysql.staff VALUES ('800122337', 'Rajesh', 'G', 'Kardakarna', 'M', 38000, '333445555');
+INSERT INTO expert_mysql.staff VALUES ('820123637', 'Monty', 'C', 'Smythe', 'M', 38000, '333445555');
+INSERT INTO expert_mysql.staff VALUES ('830132335', 'Richard', 'E', 'Jones', 'M', 38000, '333445555');
+INSERT INTO expert_mysql.staff VALUES ('333445665', 'Edward', 'E', 'Engles', 'M', 25000, '333445555');
+INSERT INTO expert_mysql.staff VALUES ('123654321', 'Beware', 'D', 'Borg', 'F', 55000, '333444444');
+INSERT INTO expert_mysql.staff VALUES ('123456789', 'Wilma', 'N', 'Maxima', 'F', 43000, '333445555');
+# Data for table expert_mysql.tasking: 
+INSERT INTO expert_mysql.tasking VALUES ('333445555', '405', 23);
+INSERT INTO expert_mysql.tasking VALUES ('123763153', '405', 33.5);
+INSERT INTO expert_mysql.tasking VALUES ('921312388', '601', 44);
+INSERT INTO expert_mysql.tasking VALUES ('800122337', '300', 13);
+INSERT INTO expert_mysql.tasking VALUES ('820123637', '300', 9.5);
+INSERT INTO expert_mysql.tasking VALUES ('830132335', '401', 8.5);
+INSERT INTO expert_mysql.tasking VALUES ('333445555', '300', 11);
+INSERT INTO expert_mysql.tasking VALUES ('921312388', '500', 13);
+INSERT INTO expert_mysql.tasking VALUES ('800122337', '300', 44);
+INSERT INTO expert_mysql.tasking VALUES ('820123637', '401', 500.5);
+INSERT INTO expert_mysql.tasking VALUES ('830132335', '400', 12);
+INSERT INTO expert_mysql.tasking VALUES ('333445665', '600', 300.25);
+INSERT INTO expert_mysql.tasking VALUES ('123654321', '607', 444.75);
+INSERT INTO expert_mysql.tasking VALUES ('123456789', '300', 1000);
+#...done.

=== added file 'mysql-test/r/ch12.result'
--- mysql-test/r/ch12.result	1970-01-01 00:00:00 +0000
+++ mysql-test/r/ch12.result	2012-09-16 03:48:14 +0000
@@ -0,0 +1,143 @@
+DROP DATABASE IF EXISTS expert_mysql;
+Warnings:
+Note	1008	Can't drop database 'expert_mysql'; database doesn't exist
+CREATE DATABASE expert_mysql;
+USE expert_mysql;
+CREATE TABLE `building` (
+`dir_code` char(4) NOT NULL,
+`building` char(6) NOT NULL
+) ENGINE=MyISAM DEFAULT CHARSET=latin1;
+CREATE TABLE `directorate` (
+`dir_code` char(4) NOT NULL,
+`dir_name` char(30) DEFAULT NULL,
+`dir_head_id` char(9) DEFAULT NULL,
+PRIMARY KEY (`dir_code`)
+) ENGINE=MyISAM DEFAULT CHARSET=latin1;
+CREATE TABLE `staff` (
+`id` char(9) NOT NULL,
+`first_name` char(20) DEFAULT NULL,
+`mid_name` char(20) DEFAULT NULL,
+`last_name` char(30) DEFAULT NULL,
+`sex` char(1) DEFAULT NULL,
+`salary` int(11) DEFAULT NULL,
+`mgr_id` char(9) DEFAULT NULL,
+PRIMARY KEY (`id`)
+) ENGINE=MyISAM DEFAULT CHARSET=latin1;
+CREATE TABLE `tasking` (
+`id` char(9) NOT NULL,
+`project_number` char(9) NOT NULL,
+`hours_worked` double DEFAULT NULL
+) ENGINE=MyISAM DEFAULT CHARSET=latin1;
+USE expert_mysql;
+INSERT INTO expert_mysql.building VALUES ('N41', '1300');
+INSERT INTO expert_mysql.building VALUES ('N01', '1453');
+INSERT INTO expert_mysql.building VALUES ('M00', '1000');
+INSERT INTO expert_mysql.building VALUES ('N41', '1301');
+INSERT INTO expert_mysql.building VALUES ('N41', '1305');
+INSERT INTO expert_mysql.directorate VALUES ('N41', 'Development', '333445555');
+INSERT INTO expert_mysql.directorate VALUES ('N01', 'Human Resources', '123654321');
+INSERT INTO expert_mysql.directorate VALUES ('M00', 'Management', '333444444');
+INSERT INTO expert_mysql.staff VALUES ('333445555', 'John', 'Q', 'Smith', 'M', 30000, '333444444');
+INSERT INTO expert_mysql.staff VALUES ('123763153', 'William', 'E', 'Walters', 'M', 25000, '123654321');
+INSERT INTO expert_mysql.staff VALUES ('333444444', 'Alicia', 'F', 'St.Cruz', 'F', 25000, 'None');
+INSERT INTO expert_mysql.staff VALUES ('921312388', 'Goy', 'X', 'Hong', 'F', 40000, '123654321');
+INSERT INTO expert_mysql.staff VALUES ('800122337', 'Rajesh', 'G', 'Kardakarna', 'M', 38000, '333445555');
+INSERT INTO expert_mysql.staff VALUES ('820123637', 'Monty', 'C', 'Smythe', 'M', 38000, '333445555');
+INSERT INTO expert_mysql.staff VALUES ('830132335', 'Richard', 'E', 'Jones', 'M', 38000, '333445555');
+INSERT INTO expert_mysql.staff VALUES ('333445665', 'Edward', 'E', 'Engles', 'M', 25000, '333445555');
+INSERT INTO expert_mysql.staff VALUES ('123654321', 'Beware', 'D', 'Borg', 'F', 55000, '333444444');
+INSERT INTO expert_mysql.staff VALUES ('123456789', 'Wilma', 'N', 'Maxima', 'F', 43000, '333445555');
+INSERT INTO expert_mysql.tasking VALUES ('333445555', '405', 23);
+INSERT INTO expert_mysql.tasking VALUES ('123763153', '405', 33.5);
+INSERT INTO expert_mysql.tasking VALUES ('921312388', '601', 44);
+INSERT INTO expert_mysql.tasking VALUES ('800122337', '300', 13);
+INSERT INTO expert_mysql.tasking VALUES ('820123637', '300', 9.5);
+INSERT INTO expert_mysql.tasking VALUES ('830132335', '401', 8.5);
+INSERT INTO expert_mysql.tasking VALUES ('333445555', '300', 11);
+INSERT INTO expert_mysql.tasking VALUES ('921312388', '500', 13);
+INSERT INTO expert_mysql.tasking VALUES ('800122337', '300', 44);
+INSERT INTO expert_mysql.tasking VALUES ('820123637', '401', 500.5);
+INSERT INTO expert_mysql.tasking VALUES ('830132335', '400', 12);
+INSERT INTO expert_mysql.tasking VALUES ('333445665', '600', 300.25);
+INSERT INTO expert_mysql.tasking VALUES ('123654321', '607', 444.75);
+INSERT INTO expert_mysql.tasking VALUES ('123456789', '300', 1000);
+DBXP_SELECT first_name, last_name, sex, id FROM staff;
+first_name	last_name	sex	id
+John	Smith	M	333445555
+William	Walters	M	123763153
+Alicia	St.Cruz	F	333444444
+Goy	Hong	F	921312388
+Rajesh	Kardakarna	M	800122337
+Monty	Smythe	M	820123637
+Richard	Jones	M	830132335
+Edward	Engles	M	333445665
+Beware	Borg	F	123654321
+Wilma	Maxima	F	123456789
+DBXP_SELECT id FROM staff;
+id
+333445555
+123763153
+333444444
+921312388
+800122337
+820123637
+830132335
+333445665
+123654321
+123456789
+DBXP_SELECT dir_name FROM directorate;
+dir_name
+Development
+Human Resources
+Management
+DBXP_SELECT id, dir_name FROM staff 
+JOIN directorate ON staff.mgr_id = directorate.dir_head_id;
+id	dir_name
+123763153	Human Resources
+921312388	Human Resources
+333445555	Management
+123654321	Management
+800122337	Development
+820123637	Development
+830132335	Development
+333445665	Development
+123456789	Development
+DBXP_SELECT id, dir_name FROM staff, directorate  
+WHERE staff.mgr_id = directorate.dir_head_id;
+id	dir_name
+123763153	Human Resources
+921312388	Human Resources
+333445555	Management
+123654321	Management
+800122337	Development
+820123637	Development
+830132335	Development
+333445665	Development
+123456789	Development
+DBXP_SELECT * FROM staff WHERE staff.id = '123456789';
+id	first_name	mid_name	last_name	sex	salary	mgr_id
+123456789	Wilma	N	Maxima	F	43000	333445555
+DBXP_SELECT first_name, last_name FROM staff join directorate ON staff.mgr_id = directorate.dir_head_id
+WHERE directorate.dir_code = 'N41';
+first_name	last_name
+Rajesh	Kardakarna
+Monty	Smythe
+Richard	Jones
+Edward	Engles
+Wilma	Maxima
+DBXP_SELECT * FROM directorate JOIN building ON directorate.dir_code = building.dir_code;
+dir_code	dir_name	dir_head_id	dir_code	building
+M00	Management	333444444	M00	1000
+N01	Human Resources	123654321	N01	1453
+N41	Development	333445555	N41	1300
+N41	Development	333445555	N41	1301
+N41	Development	333445555	N41	1305
+DBXP_SELECT directorate.dir_code, dir_name, building, dir_head_id 
+FROM directorate JOIN building ON directorate.dir_code = building.dir_code;
+dir_code	dir_name	building	dir_head_id
+M00	Management	1000	333444444
+N01	Human Resources	1453	123654321
+N41	Development	1300	333445555
+N41	Development	1301	333445555
+N41	Development	1305	333445555
+DROP DATABASE expert_mysql;

=== added file 'mysql-test/t/ch12.test'
--- mysql-test/t/ch12.test	1970-01-01 00:00:00 +0000
+++ mysql-test/t/ch12.test	2012-09-16 03:50:04 +0000
@@ -0,0 +1,38 @@
+#
+# Sample test to test the DBXP_SELECT execution
+#
+
+--source include/ch14.sql
+
+# Test 1: 
+DBXP_SELECT first_name, last_name, sex, id FROM staff;
+
+# Test 2: 
+DBXP_SELECT id FROM staff;
+
+# Test 3: 
+DBXP_SELECT dir_name FROM directorate;
+
+# Test 4a: 
+DBXP_SELECT id, dir_name FROM staff 
+JOIN directorate ON staff.mgr_id = directorate.dir_head_id;
+
+# Test 4b: 
+DBXP_SELECT id, dir_name FROM staff, directorate  
+WHERE staff.mgr_id = directorate.dir_head_id;
+
+# Test 5: 
+DBXP_SELECT * FROM staff WHERE staff.id = '123456789';
+
+# Test 6: 
+DBXP_SELECT first_name, last_name FROM staff join directorate ON staff.mgr_id = directorate.dir_head_id
+WHERE directorate.dir_code = 'N41';
+
+# Test 7: 
+DBXP_SELECT * FROM directorate JOIN building ON directorate.dir_code = building.dir_code;
+
+# Test 8: 
+DBXP_SELECT directorate.dir_code, dir_name, building, dir_head_id 
+FROM directorate JOIN building ON directorate.dir_code = building.dir_code;
+
+DROP DATABASE expert_mysql;

=== modified file 'sql/CMakeLists.txt'
--- sql/CMakeLists.txt	2012-08-07 05:14:58 +0000
+++ sql/CMakeLists.txt	2012-09-13 22:28:13 +0000
@@ -132,6 +132,10 @@ SET(SQL_SHARED_SOURCES
   sql_manager.cc
   sql_optimizer.cc
   sql_parse.cc
+  sql_dbxp_parse.cc
+  query_tree.cc
+  expression.cc
+  attribute.cc
   sql_partition.cc
   sql_partition_admin.cc
   sql_planner.cc

=== added file 'sql/attribute.cc'
--- sql/attribute.cc	1970-01-01 00:00:00 +0000
+++ sql/attribute.cc	2012-09-16 17:27:46 +0000
@@ -0,0 +1,240 @@
+/*
+  attribute.cc
+
+  DESCRIPTION
+    This file contains methods to encapsulate the attributes in a query.
+
+  SEE ALSO
+    attribute.h
+*/
+#include "attribute.h"
+
+/*
+  Constructor
+
+  SYNOPSIS
+    Attribute()
+
+  DESCRIPTION
+    Initializes the hidden attribute array.
+*/
+Attribute::Attribute(void)
+{
+  int i;
+  for (i = 0; i < 256; i++)
+    hidden[i] = false;
+}
+
+/*
+  Remove Attribute
+
+  SYNOPSIS
+    remove_attribute()
+    int num IN the number (starting at 0) of the sttribute to drop.
+
+  DESCRIPTION
+    This method removes the attribute from the collection.
+
+  RETURN VALUE
+    Success = true
+    Failed = false
+*/
+int Attribute::remove_attribute(int num)
+{
+  int j = 0;
+  List_iterator<Item> it(attr_list);
+  Item *item = NULL;
+
+  DBUG_ENTER("remove_attribute");
+  if (num >= (int)attr_list.elements || num < 0)
+    DBUG_RETURN(false);
+  while ((item = it++))
+  {
+    if (j == num)
+    {
+      it.remove();
+      DBUG_RETURN(true);
+    }
+    j++;
+  }
+  DBUG_RETURN(false);
+}
+
+/*
+  Get Attribute
+
+  SYNOPSIS
+    get_attribute()
+    int num IN the number of attribute to retrieve.
+
+  DESCRIPTION
+    This method returns the attribute at the index specified.
+
+  RETURN VALUE
+    Success = Item *
+    Failed = NULL
+*/
+Item *Attribute::get_attribute(int num)
+{
+  int j = 0;
+  List<Item> it(attr_list);
+  Item *item = it.pop();
+
+  DBUG_ENTER("get_attribute");
+  if (num >= (int)attr_list.elements || num < 0)
+    DBUG_RETURN(NULL);
+  while ((j != num) && (item != NULL))
+  {
+    item = it.pop();
+    j++;
+  }
+  if (j != num)
+    item = 0;
+  DBUG_RETURN(item);
+}
+
+/*
+  Add Attribute
+
+  SYNOPSIS
+    add_attribute()
+    bool append IN do you want to append (true) or prepend (false)?
+    Item *new_item IN the item to be added.
+
+  DESCRIPTION
+    This method adds the attribute at the front or back of the list.
+
+  RETURN VALUE
+    Success = 0
+    Failed = 1
+*/
+int Attribute::add_attribute(bool append, Item *new_item)
+{
+  DBUG_ENTER("add_attribute");
+  if (append)
+    attr_list.push_back(new_item);
+  else
+    attr_list.push_front(new_item);
+  DBUG_RETURN(0);
+}
+
+/*
+  Number of Attributes
+
+  SYNOPSIS
+    num_attributes()
+
+  DESCRIPTION
+    This method returns the number of attributes in the list.
+
+  RETURN VALUE
+    int Number of attributes in list
+*/
+int Attribute::num_attributes()
+{
+  DBUG_ENTER("num_attributes");
+  DBUG_RETURN(attr_list.elements);
+}
+
+/*
+  Find index of Attribute
+
+  SYNOPSIS
+    index_of()
+    char *table IN table name of the attribute
+    char *value IN the name of the attribute
+
+  DESCRIPTION
+    This method returns the index (number) of attribute specified.
+
+  RETURN VALUE
+    Success = int Number of attribute
+    Failed = -1
+*/
+int Attribute::index_of(char *table, char *value)
+{
+  List_iterator<Item> it(attr_list);
+  Item *item;
+  int i = 0;
+  int j = -1;
+  bool found = false;
+
+  DBUG_ENTER("index_of");
+  while ((item = it++) && !found)
+  {
+    if ((strcasecmp(((Field *)item)->field_name, value) == 0) &&
+       ((table == NULL) ||
+       (strcasecmp(*((Field *)item)->table_name, table) == 0)))
+    {
+      j = i;
+      found = true;
+    }
+    i++;
+  }
+  DBUG_RETURN(j);
+}
+
+/*
+  Hide Attribute
+
+  SYNOPSIS
+    hide_attribute()
+    int num IN the number of attribute to hide.
+
+  DESCRIPTION
+    This method sets the hidden property of the attribute to specify
+    that the attribute is not to be sent to the client (used internally)
+    by the optimizer.
+
+  RETURN VALUE
+    Success = 0
+    Failed = -1
+*/
+int Attribute::hide_attribute(Item *item, bool hide)
+{
+  int i;
+  DBUG_ENTER("hide_attribute");
+  i = index_of((char *)*((Field *)item)->table_name, 
+               (char *)((Field *)item)->field_name);
+  if (i > -1)
+    hidden[i] = hide;
+  DBUG_RETURN(0);
+}
+
+/*
+  Get string value of attributes
+
+  SYNOPSIS
+    to_string()
+
+  DESCRIPTION
+    This method returns a formatted string of the attributes in the list.
+
+  RETURN VALUE
+    Success = char *
+    Failed = ""
+*/
+char *Attribute::to_string()
+{
+  List_iterator<Item> it(attr_list);
+  char *str = (char *)my_malloc(1024, MYF(MY_ZEROFILL | MY_WME));
+  Item *item;
+  int j = 0;
+
+  DBUG_ENTER("to_string");
+  strcpy(str, "");
+  while ((item = it++))
+  {
+    if (j)
+      strcat(str, ", ");
+    if (*((Field *)item)->table_name)
+    {
+      strcat(str, *((Field *)item)->table_name);
+      strcat(str, ".");
+    }
+    strcat(str, ((Field *)item)->field_name);
+    if (!j)
+      j = 1;
+  }
+  DBUG_RETURN(str);
+}

=== added file 'sql/attribute.h'
--- sql/attribute.h	1970-01-01 00:00:00 +0000
+++ sql/attribute.h	2012-09-13 22:28:13 +0000
@@ -0,0 +1,19 @@
+#include "sql_priv.h"
+#include "sql_class.h"
+#include "table.h"
+
+class Attribute
+{
+public:
+  Attribute(void);
+  int remove_attribute(int num);
+  Item *get_attribute(int num);
+  int add_attribute(bool append, Item *new_item);
+  int num_attributes();
+  int index_of(char *table, char *value);
+  int hide_attribute(Item *item, bool hide);
+  char *to_string();
+private:
+  List<Item> attr_list;
+  bool hidden[256];
+};

=== added file 'sql/expression.cc'
--- sql/expression.cc	1970-01-01 00:00:00 +0000
+++ sql/expression.cc	2012-09-16 17:27:46 +0000
@@ -0,0 +1,684 @@
+/*
+  expression.cc
+
+  DESCRIPTION
+    This file contains methods to encapsulate the expressions in a query.
+
+  SEE ALSO
+    expression.h
+*/ 
+#include "expression.h"
+
+/*
+  Constructor
+
+  SYNOPSIS
+    Expression()
+
+  DESCRIPTION
+    Initializes the private variables.
+*/
+Expression::Expression(void) 
+{
+  root = NULL;
+  num_expr = 0;
+}
+
+/*
+  Remove Expression
+
+  SYNOPSIS
+    remove_expression()
+    int num IN the number (starting at 0) of the sttribute to drop.
+
+  DESCRIPTION
+    This method removes the expression from the collection.
+
+  RETURN VALUE
+    Success = true
+    Failed = false
+*/
+int Expression::remove_expression(int num, bool free)
+{
+  expr_node *p = root;
+  expr_node *q = NULL;
+  int j = 0;
+
+  DBUG_ENTER("remove_expression");
+  if (num >= num_expr || num < 0)
+    DBUG_RETURN(false);
+  while ((j != num) && (p != NULL))
+  {
+    q = p;
+    p = p->next;
+    j++;
+  }
+  if (j == 0)
+    root = root->next;
+  else if (j == num)
+  {
+    if (q != NULL)
+      q->next = p->next;
+    else
+      root = NULL;
+  }
+  num_expr--;
+  if (free)
+    my_free(p);
+  DBUG_RETURN(true);
+}
+
+/*
+  Get Expression
+
+  SYNOPSIS
+    get_expression()
+    int num IN the number of expression to retrieve.
+
+  DESCRIPTION
+    This method returns the expression at the index specified.
+
+  RETURN VALUE
+    Success = expr_node *
+    Failed = NULL
+*/
+expr_node *Expression::get_expression(int num)
+{
+  int j = 0;
+  expr_node *p = root;
+
+  DBUG_ENTER("get_expression");
+  if (num >= num_expr || num < 0)
+    DBUG_RETURN(NULL);
+  while ((j != num) && (p != NULL))
+  {
+    p = p->next;
+    j++;
+  }
+  if (j == num)
+    DBUG_RETURN(p);
+  else
+    DBUG_RETURN(NULL);
+}
+
+/*
+  Add Expression
+
+  SYNOPSIS
+    add_expression()
+    bool append IN do you want to append (true) or prepend (false)?
+    expr_node *new_item IN the item to be added.
+
+  DESCRIPTION
+    This method adds the expression at the front or back of the list.
+
+  RETURN VALUE
+    Success = 0
+    Failed = 1
+*/
+int Expression::add_expression(bool append, expr_node *new_item)
+{
+  expr_node *p = root;
+
+  DBUG_ENTER("add_expression");
+  if (append)
+    if (root == NULL)
+      root = new_item;
+    else
+    {
+      while (p->next != NULL)
+        p = p->next;
+      if (p == root)
+        root->next = new_item;
+      else
+        p->next = new_item;
+      new_item->next = NULL;
+    }
+  else
+  {
+    root = new_item;
+    root->next = p;
+  }
+  num_expr++;
+  DBUG_RETURN(0);
+}
+
+/*
+  Number of Expressions
+
+  SYNOPSIS
+    num_expressions()
+
+  DESCRIPTION
+    This method returns the number of expressions in the list.
+
+  RETURN VALUE
+    int Number of expressions in list
+*/
+int Expression::num_expressions()
+{
+  DBUG_ENTER("num_expressions");
+  DBUG_RETURN(num_expr);
+}
+
+/*
+  Find index of Expression
+
+  SYNOPSIS
+    index_of()
+    char *table IN table name of the expression
+    char *value IN the name of the expression
+
+  DESCRIPTION
+    This method returns the index (number) of expression specified.
+
+  RETURN VALUE
+    Success = int Number of expression
+    Failed = -1
+*/
+int Expression::index_of(char *table, char *value)
+{
+  expr_node *p = root;
+  bool found = false;
+  int i = 0;
+
+  DBUG_ENTER("index_of");
+  while ((p != NULL) && !found)
+  {
+    i++;
+    if ((strcasecmp(((Item_field *)p->left_op)->field_name, value) == 0) &&
+       ((table == NULL) ||
+       (strcasecmp(((Item_field *)p->left_op)->table_name, table) == 0)))
+      found = true;
+    else if ((strcasecmp(((Item_field *)p->right_op)->field_name, value) == 0) &&
+       ((table == NULL) ||
+       (strcasecmp(((Item_field *)p->right_op)->table_name, table) == 0)))
+      found = true;
+    else 
+      p = p->next;
+  }
+  DBUG_RETURN(i);
+}
+
+/*
+  Does the expression list have the table?
+
+  SYNOPSIS
+    has_table()
+    char * IN The name of the table.
+
+  DESCRIPTION
+    This method searches the expression list to see if the table passed in
+    is referenced in the list of expressions.
+
+  RETURN VALUE
+    Success = true
+    Failed = false
+*/
+bool Expression::has_table(char *table)
+{
+  expr_node *p = root;
+  bool found = false;
+  int i;
+  int j;
+
+  DBUG_ENTER("has_table");
+  while ((p != NULL) && !found)
+  {
+    if (p->left_op->type() == Item::FIELD_ITEM)
+      i = strcasecmp((char *)((Item_field *)p->left_op)->table_name, 
+                     table);
+    else
+      i = -1;
+    if (p->right_op->type() == Item::FIELD_ITEM)
+      j = strcasecmp((char *)((Item_field *)p->right_op)->table_name,
+                     table);
+    else
+      j = -1;
+    if ((i == 0) || (j == 0))
+      found = true;
+    else 
+      p = p->next;
+  }
+  DBUG_RETURN(found);
+}
+
+/*
+  Reduce expressions to minimal expression.
+
+  SYNOPSIS
+    reduce_expressions()
+    TABLE * IN The table that the expression references
+
+  DESCRIPTION
+    This method eliminates "dead" or always true expressions from the list.
+
+  RETURN VALUE
+    Success = 0
+    Failed = 1
+*/
+int Expression::reduce_expressions(TABLE *table)
+{
+  DBUG_ENTER("reduce_expressions");
+  DBUG_RETURN(0);
+}
+
+/*
+  Convert LEX structure to Expression class.
+
+  SYNOPSIS
+    convert()
+    Item * IN The lex structure to convert.
+
+  DESCRIPTION
+    This method parses a lex->where or lex->on_expr to the Expression class
+    adding the expressions to the list.
+
+  RETURN VALUE
+    Success = 0
+    Failed = 1
+*/
+int Expression::convert(THD *thd, Item *mysql_expr)
+{
+  Item *pcond = mysql_expr;
+
+  DBUG_ENTER("convert");
+  if (pcond == NULL)
+    DBUG_RETURN(0);
+  while (pcond != NULL)
+  {
+    expr_node *enode = (expr_node *)my_malloc(sizeof(expr_node), 
+                                              MYF(MY_ZEROFILL | MY_WME));
+    if (pcond->type() == Item::COND_ITEM)
+    {
+      enode->junction = pcond;
+      pcond = pcond->next;  
+    }
+    else
+      enode->junction = NULL;
+    enode->operation = pcond;
+    pcond = pcond->next;
+    if (pcond == NULL)
+      break;
+    if (pcond->type() == Item::FIELD_ITEM)
+    {
+      if (!pcond->fixed)
+        pcond->fix_fields(thd, &pcond);
+    }
+    enode->right_op = pcond;
+    pcond = pcond->next;
+    if (pcond == NULL)
+      break;
+    if (pcond->type() == Item::FIELD_ITEM)
+    {
+      if (!pcond->fixed)
+        pcond->fix_fields(thd, &pcond);
+    }
+    enode->left_op = pcond;
+    enode->next = NULL;
+    add_expression(true, enode);
+    pcond = pcond->next;
+    if (pcond != NULL)
+      if (pcond->next == NULL)
+        pcond = NULL;
+  }
+  DBUG_RETURN(0);
+}
+
+/*
+  Get string value of expressions
+
+  SYNOPSIS
+    to_string()
+
+  DESCRIPTION
+    This method returns a formatted string of the expressions in the list.
+
+  RETURN VALUE
+    Success = char *
+    Failed = ""
+*/
+char *Expression::to_string()
+{
+  char *str = (char *)my_malloc(1024, MYF(MY_ZEROFILL | MY_WME));
+  Item *pcond;
+
+  DBUG_ENTER("to_string");
+  strcpy(str, "");
+  if (root == NULL)
+    DBUG_RETURN((char *)"<none>");
+  pcond = root->left_op;
+  while (pcond->next)
+  {
+    strcat(str, " (");
+    if (pcond->type() == Item::FIELD_ITEM)
+    {
+      strcat(str, ((Item_field *)pcond)->field_name);
+    }
+    else
+    {
+      strcat(str, "COND_ITEM");
+    }
+    strcat(str, ")");
+    pcond = pcond->next;
+  }
+  DBUG_RETURN(str);
+}
+
+/*
+  Get field in table.
+
+  SYNOPSIS
+    find_field()
+    TABLE *table IN the table to search
+    char *name IN the field name to search for
+
+  DESCRIPTION
+    This method returns the field class that matches the field name.
+
+  RETURN VALUE
+    Success = Field *
+    Failed = NULL
+*/
+Field *Expression::find_field(TABLE *tbl, char *name)
+{
+  DBUG_ENTER("find_field");
+  for (Field **field = tbl->field; *field; field++)
+  {
+    if (strcasecmp((*field)->field_name, name) == 0)
+      DBUG_RETURN((*field));
+  }
+  DBUG_RETURN(NULL);
+}
+
+/*
+  Compare join values.
+
+  SYNOPSIS
+    compare_join()
+    expr_node *expr IN the expression to evaluate
+    TABLE *t1 IN the left table to compare
+    TABLE *t2 IN the left table to compare
+
+  DESCRIPTION
+    This method compares the values and returns the result
+
+  RETURN VALUE
+    Success = true
+    Failed = false
+*/
+int Expression::compare_join(expr_node *expr, TABLE *t1, TABLE *t2)
+{
+  char buff1[MAX_FIELD_WIDTH];
+  char buff2[MAX_FIELD_WIDTH];
+  String str1(buff1,sizeof(buff1),&my_charset_bin);
+  String str2(buff2,sizeof(buff2),&my_charset_bin);
+
+  DBUG_ENTER("compare_join");
+  if (expr == NULL)
+    DBUG_RETURN(-1);
+  if ((expr->left_op == NULL) || (expr->right_op == NULL) ||
+      (expr->operation == NULL))
+    DBUG_RETURN(-1);
+  /*
+    If both are fields, compare the field values. (join)
+  */
+  if ((expr->left_op->type() == Item::FIELD_ITEM) &&
+     (expr->right_op->type() == Item::FIELD_ITEM))
+  {
+    int i;
+    Field *fl = find_field(t1, (char *)((Item_field *)expr->left_op)->field_name);
+    fl->val_str(&str1);
+    int fl_len = str1.length();
+    Field *fr = find_field(t2, (char *)((Item_field *)expr->right_op)->field_name);
+    fr->val_str(&str2);
+    int fr_len = str2.length();
+    
+    i = memcmp(str1.ptr(), str2.ptr(), fl_len < fr_len ? fl_len : fr_len);
+    DBUG_RETURN(i);
+  }
+  DBUG_RETURN(90125);
+}
+
+/*
+  Compare values.
+
+  SYNOPSIS
+    compare()
+    expr_node *expr IN the expression to evaluate
+    TABLE *t1 IN the left table to compare
+
+  DESCRIPTION
+    This method compares the values and returns the result
+
+  RETURN VALUE
+    Success = true
+    Failed = false
+*/
+bool Expression::compare(expr_node *expr, TABLE *t1)
+{
+  bool result = false;
+
+  DBUG_ENTER("compare");
+  if (expr == NULL)
+    DBUG_RETURN(-1);
+  if ((expr->left_op == NULL) || (expr->right_op == NULL) ||
+      (expr->operation == NULL))
+    DBUG_RETURN(-1);
+  /*
+    Check for compare integers.
+  */
+  if ((expr->left_op->type() == Item::INT_ITEM) ||
+      (expr->right_op->type() == Item::INT_ITEM))
+  {
+    longlong a = 0;
+    longlong b = 0;
+    Field *f;
+
+    if(expr->left_op->type() == Item::FIELD_ITEM)
+    {
+      f = find_field(t1, (char *)((Item_field *)expr->left_op)->field_name);
+      if (f == NULL)
+        DBUG_RETURN(-1);
+      a = f->val_int();
+    }
+    else
+      a = atol(expr->left_op->item_name.ptr());
+    if(expr->right_op->type() == Item::FIELD_ITEM)
+    {
+      f = find_field(t1, (char *)((Item_field *)expr->right_op)->field_name);
+      if (f == NULL)
+        DBUG_RETURN(-1);
+      b = f->val_int();
+    }
+    else
+      b = atol(expr->right_op->item_name.ptr());
+    switch(((Item_func *)expr->operation)->functype())
+    {
+      case Item_func::EQ_FUNC:
+        DBUG_RETURN(a == b);
+      case Item_func::NE_FUNC:
+        DBUG_RETURN(a != b);
+      case Item_func::LT_FUNC:
+        DBUG_RETURN(a < b);
+      case Item_func::LE_FUNC:
+        DBUG_RETURN(a <= b);
+      case Item_func::GT_FUNC:
+        DBUG_RETURN(a > b);
+      case Item_func::GE_FUNC:
+        DBUG_RETURN(a >= b);
+      default:
+        DBUG_RETURN(false);
+    }
+  }
+  /*
+    Check for compare strings.
+  */
+  else if ((expr->left_op->type() == Item::STRING_ITEM) ||
+           (expr->right_op->type() == Item::STRING_ITEM))
+  {
+    char buff1[MAX_FIELD_WIDTH];
+    char buff2[MAX_FIELD_WIDTH];
+    String str1(buff1,sizeof(buff1),&my_charset_bin);
+    String str2(buff2,sizeof(buff2),&my_charset_bin);
+    char *a = NULL;
+    char *b = NULL;
+    int i, l, r;
+    Field *f;
+
+    if(expr->left_op->type() == Item::FIELD_ITEM)
+    {
+      f = find_field(t1, (char *)((Item_field *)expr->left_op)->field_name);
+      if (f == NULL)
+        DBUG_RETURN(-1);
+      f->val_str(&str1);
+      a = (char *)str1.ptr();
+      l = str1.length();
+    }
+    else
+    {
+      a = (char *)expr->left_op->item_name.ptr();
+      l = strlen(a);
+    }
+    if(expr->right_op->type() == Item::FIELD_ITEM)
+    {
+      f = find_field(t1, (char *)((Item_field *)expr->right_op)->field_name);
+      if (f == NULL)
+        DBUG_RETURN(-1);
+      f->val_str(&str2);
+      b = (char *)str2.ptr();
+      r = str2.length();
+    }
+    else
+    {
+      b = (char *)expr->right_op->item_name.ptr();
+      r = strlen(b);
+    }
+    i = strncasecmp(a, b, l < r ? l : r);
+    switch(((Item_func *)expr->operation)->functype())
+    {
+      case Item_func::EQ_FUNC:
+        DBUG_RETURN(i == 0);
+      case Item_func::NE_FUNC:
+        DBUG_RETURN(i != 0);
+      case Item_func::LT_FUNC:
+        DBUG_RETURN(i < 0);
+      case Item_func::LE_FUNC:
+        DBUG_RETURN(i <= 0);
+      case Item_func::GT_FUNC:
+        DBUG_RETURN(i > 0);
+      case Item_func::GE_FUNC:
+        DBUG_RETURN(i >= 0);
+      default:
+        DBUG_RETURN(false);
+    }
+  }
+  /*
+    Check for compare decimal.
+  */
+  else if ((expr->left_op->type() == Item::DECIMAL_ITEM) ||
+           (expr->right_op->type() == Item::DECIMAL_ITEM))
+  {
+    my_decimal *a = new my_decimal();
+    my_decimal *b = new my_decimal();
+    Field *f;
+
+    if(expr->left_op->type() == Item::FIELD_ITEM)
+    {
+      f = find_field(t1, (char *)((Item_field *)expr->left_op)->field_name);
+      if (f == NULL)
+        DBUG_RETURN(-1);
+      a = f->val_decimal(a);
+    }
+    else
+      str2my_decimal(E_DEC_FATAL_ERROR, expr->left_op->item_name.ptr(), 
+        expr->left_op->item_name.length(), system_charset_info, a);
+    if(expr->right_op->type() == Item::FIELD_ITEM)
+    {
+      f = find_field(t1, (char *)((Item_field *)expr->right_op)->field_name);
+      if (f == NULL)
+        DBUG_RETURN(-1);
+      b = f->val_decimal(b);
+    }
+    else
+      str2my_decimal(E_DEC_FATAL_ERROR, expr->right_op->item_name.ptr(), 
+        expr->right_op->item_name.length(), system_charset_info, b);
+    a->fix_buffer_pointer();
+    b->fix_buffer_pointer();
+    result = (decimal_cmp((decimal_t*) a, (decimal_t*) b) == 0);
+    DBUG_RETURN (result);
+  }
+  DBUG_RETURN(result);
+}
+
+/*
+  Evaluation expression conditions.
+
+  SYNOPSIS
+    evaluate()
+    TABLE *table1 IN the left table to compare
+
+  DESCRIPTION
+    This method evalutates the expression and returns the result
+
+  RETURN VALUE
+    Success = true
+    Failed = false
+*/
+bool Expression::evaluate(TABLE *table1)
+{
+  bool result = false;
+  expr_node *node = root;
+  Item_func *junction = NULL;
+
+  DBUG_ENTER("evaluate");
+  while (node != NULL)
+  {
+    if (node == root)
+    {
+      result = compare(node, table1);
+      if (node->junction != NULL)
+        junction = (Item_func *)node->junction;
+      else
+        junction = NULL;
+    }
+    else
+      switch (junction->functype())
+      {
+         case Item_func::COND_AND_FUNC:
+          result = result && compare(node, table1);
+          break;
+        case Item_func::COND_OR_FUNC:
+          result = result || compare(node, table1);
+          break;
+        default:
+          DBUG_RETURN(false);
+      }
+    node = node->next;
+  }
+  DBUG_RETURN (result);
+}
+
+int Expression::get_join_expr(Expression *where_expr)
+{
+  bool result = false;
+  expr_node *node;
+  int i = 0;
+
+  DBUG_ENTER("get_join_expr");
+  node = where_expr->get_expression(i);
+  while (node != NULL)
+  {
+    if ((node->left_op->type() == Item::FIELD_ITEM) &&
+        (node->right_op->type() == Item::FIELD_ITEM))
+    {
+      where_expr->remove_expression(i, false);
+      node->next = NULL;
+      add_expression(true, node);
+      i--;
+    }
+    i++;
+    node = where_expr->get_expression(i);
+  }
+  DBUG_RETURN (result);
+}

=== added file 'sql/expression.h'
--- sql/expression.h	1970-01-01 00:00:00 +0000
+++ sql/expression.h	2012-09-16 00:40:58 +0000
@@ -0,0 +1,36 @@
+#include "sql_priv.h"
+#include "sql_class.h"
+#include "table.h"
+#include <sql_string.h>
+
+struct expr_node
+{
+  Item      *left_op;
+  Item      *operation;
+  Item      *right_op;
+  Item      *junction;
+  expr_node *next;
+};
+
+class Expression
+{
+public:
+  Expression(void);
+  int remove_expression(int num, bool free);
+  expr_node *get_expression(int num);
+  int add_expression(bool append, expr_node *new_item);
+  int num_expressions();
+  int index_of(char *table, char *value);
+  int reduce_expressions(TABLE *table);
+  bool has_table(char *table);
+  int convert(THD *thd, Item *mysql_expr);
+  char *to_string();
+  bool evaluate(TABLE *table1);
+  int compare_join(expr_node *expr, TABLE *t1, TABLE *t2);
+  int get_join_expr(Expression *where_expr);
+private:
+  expr_node *root;
+  Field *find_field(TABLE *tbl, char *name);
+  bool compare(expr_node *expr, TABLE *t1);
+  int num_expr;
+};

=== modified file 'sql/lex.h'
--- sql/lex.h	2012-09-11 17:35:40 +0000
+++ sql/lex.h	2012-09-13 22:28:13 +0000
@@ -160,6 +160,11 @@ static SYMBOL symbols[] = {
   { "DAY_MICROSECOND",	SYM(DAY_MICROSECOND_SYM)},
   { "DAY_MINUTE",	SYM(DAY_MINUTE_SYM)},
   { "DAY_SECOND",	SYM(DAY_SECOND_SYM)},
+/* BEGIN DBXP MODIFICATION */
+/* Reason for Modification: */
+/* This section identifies the symbols and values for the DBXP token */
+  { "DBXP_SELECT",         SYM(DBXP_SELECT_SYM)},
+/* END DBXP MODIFICATION */
   { "DEALLOCATE",       SYM(DEALLOCATE_SYM)},     
   { "DEC",		SYM(DECIMAL_SYM)},
   { "DECIMAL",		SYM(DECIMAL_SYM)},

=== modified file 'sql/mysqld.cc'
--- sql/mysqld.cc	2012-09-11 17:35:40 +0000
+++ sql/mysqld.cc	2012-09-13 23:27:15 +0000
@@ -3699,8 +3699,8 @@ int init_common_variables()
     the array, excluding the last element - terminator) must match the number
     of SQLCOM_ constants.
   */
-  compile_time_assert(sizeof(com_status_vars)/sizeof(com_status_vars[0]) - 1 ==
-                     SQLCOM_END + 8);
+  //compile_time_assert(sizeof(com_status_vars)/sizeof(com_status_vars[0]) - 1 ==
+   //                  SQLCOM_END + 8);
 #endif
 
   if (get_options(&remaining_argc, &remaining_argv))
@@ -8671,6 +8671,11 @@ static void set_server_version(void)
 #endif
   if (opt_log || opt_slow_log || opt_bin_log)
     strmov(end, "-log");                        // This may slow down system
+/* BEGIN DBXP MODIFICATION */
+/* Reason for Modification: */
+/* This section adds the DBXP version number to the MySQL version number. */
+  strmov(end, "-DBXP 2.0");
+/* END DBXP MODIFICATION */
 }
 
 

=== added file 'sql/query_tree.cc'
--- sql/query_tree.cc	1970-01-01 00:00:00 +0000
+++ sql/query_tree.cc	2012-09-16 17:50:01 +0000
@@ -0,0 +1,2699 @@
+/*
+  Query_tree.cc
+
+  DESCRIPTION
+    This file contains the Query_tree class. It is responsible for containing the
+    internal representation of the query to be executed. It provides methods for
+    optimizing and forming and inspecting the query tree. This class is the very
+    heart of the DBXP query capability! It also provides the ability to store
+    a binary "compiled" form of the query.
+
+  NOTES
+    The data structure is a binary tree that can have 0, 1, or 2 children. Only
+    join operations can have 2 children. All other operations have 0 or 1 
+    children. Each node in the tree is an operation and the links to children
+    are the pipeline.
+ 
+  SEE ALSO
+    query_tree.h
+*/
+#include "query_tree.h"
+
+/*
+  Constructor
+
+  SYNOPSIS
+    Query_tree::query_node()
+
+  DESCRIPTION
+    Initializes the query_node properties and arrays.
+*/
+Query_tree::query_node::query_node()
+{
+  int i; 
+
+  where_expr = NULL;
+  join_expr = NULL;
+  child = false;
+  join_cond = Query_tree::jcUN;
+  join_type = Query_tree::jnUNKNOWN;
+  left = NULL;
+  right = NULL;
+  nodeid = -1;
+  node_type = Query_tree::qntUndefined;
+  sub_query = false;
+  for (i = 0; i < MAXNODETABLES; i++)
+  {
+    relations[i] = NULL;
+    eof[i] = 0;
+    ndx[i] = -1;
+  }
+  parent_nodeid = -1;
+}
+
+/*
+  Initialize query node
+
+  SYNOPSIS
+    init_node()
+
+  DESCRIPTION
+    Initializes the query_node properties and arrays.
+*/
+int Query_tree::init_node(query_node *qn)
+{
+  int i; 
+
+  DBUG_ENTER("init_node");
+  qn->where_expr = NULL;
+  qn->join_expr = NULL;
+  qn->child = false;
+  qn->join_cond = Query_tree::jcUN;
+  qn->join_type = Query_tree::jnUNKNOWN;
+  qn->left = NULL;
+  qn->right = NULL;
+  qn->nodeid = -1;
+  qn->node_type = Query_tree::qntUndefined;
+  qn->sub_query = false;
+  for (i = 0; i < MAXNODETABLES; i++)
+  {
+    qn->relations[i] = NULL;
+    qn->eof[i] = 0;
+    qn->ndx[i] = -1;
+  }
+  qn->parent_nodeid = -1;
+  DBUG_RETURN(0);
+}
+
+/*
+  Destructor
+
+  SYNOPSIS
+    Query_tree::query_node()
+
+  DESCRIPTION
+    Destroys dynamic memory in the node.
+*/
+Query_tree::query_node::~query_node()
+{
+  if(left)
+    my_free(left);
+  if(right)
+    my_free(right);
+}
+
+/*
+  Constructor
+
+  SYNOPSIS
+    Query_tree()
+
+  DESCRIPTION
+    Initializes the query_tree properties and arrays.
+*/
+Query_tree::Query_tree(void)
+{
+  distinct = false;
+}
+
+/*
+  Destructor
+
+  SYNOPSIS
+    Query_tree()
+
+  DESCRIPTION
+    Destroys dynamic memory in the tree.
+*/
+Query_tree::~Query_tree(void)
+{
+  if(root)
+    my_free(root);
+}
+
+/*
+  Perform heuristic optimization
+
+  SYNOPSIS
+    heuristic_optimization()
+
+  DESCRIPTION
+    This method performs heuristic optimization on the query tree. The 
+    operation is destructive in that it rearranges the original tree.
+
+  RETURN VALUE
+    Success = 0  
+    Failed = 1
+*/
+int Query_tree::heuristic_optimization()
+{
+  DBUG_ENTER("heuristic_optimization");
+  query_node       *pNode;
+  query_node       *nNode;
+
+  h_opt = true;
+  /*
+    First, we have to correct the situation where restrict and
+    project are grouped together in the same node.
+  */
+  split_restrict_with_join(root);
+  split_project_with_join(root);
+  split_restrict_with_project(root);
+
+  /*
+    Find a node with restrictions and push down the tree using 
+    a recursive call. continue until you get the same node twice.
+    This means that the node cannot be pushed down any further.
+  */
+  pNode = find_restriction(root);
+  while(pNode != 0)
+  {
+    push_restrictions(root, pNode);
+    nNode = find_restriction(root);
+    /*
+      If a node is found, save a reference to it unless it is
+      either the same node as the last node found or
+      it is a leaf node. This is done so that we can ensure we
+      continue searching down the tree visiting each node once.
+    */
+    if(nNode != 0)
+    {
+      if(nNode->nodeid == pNode->nodeid)
+        pNode = 0;
+      else if(is_leaf(nNode))
+        pNode = 0;
+      else
+        pNode = nNode;
+    }
+  }
+
+  /*
+    Find a node with projections and push down the tree using 
+    a recursive call. Continue until you get the same node twice.
+    This means that the node cannot be pushed down any further.
+  */
+  pNode = find_projection(root);
+  while(pNode != 0)
+  {
+    push_projections(root, pNode);
+    nNode = find_projection(root);
+    /*
+      If a node is found, save a reference to it unless it is
+      either the same node as the last node found or
+      it is a leaf node. This is done so that we can ensure we
+      continue searching down the tree visiting each node once.
+    */
+    if(nNode != 0)
+    {
+      if(nNode->nodeid == pNode->nodeid)
+        pNode = 0;
+      else if(is_leaf(nNode))
+        pNode = 0;
+      else
+        pNode = nNode;
+    }
+  }
+
+  /*
+    Find a join node and push it down the tree using 
+    a recursive call. Continue until you get the same node twice.
+    This means that the node cannot be pushed down any further.
+  */
+  pNode = find_join(root);
+  while(pNode != 0)
+  {
+    push_joins(root, pNode);
+    nNode = find_join(root);
+    /*
+      If a node is found, save a reference to it unless it is
+      either the same node as the last node found or
+      it is a leaf node. This is done so that we can ensure we
+      continue searching down the tree visiting each node once.
+    */
+    if(nNode != 0)
+    {
+      if(nNode->nodeid == pNode->nodeid)
+        pNode = 0;
+      else if(is_leaf(nNode))
+        pNode = 0;
+      else
+        pNode = nNode;
+    }
+    else
+      pNode = nNode;
+  }
+
+  /*
+    Prune the tree of "blank" nodes
+    Blank Nodes are:
+     1) projections without attributes that have at least 1 child
+     2) restrictions without expressions
+     BUT...Can't delete a node that has TWO children!
+  */
+  prune_tree(0, root);
+
+  /*
+    Lastly, check to see if this has the DISTINCT option.
+    If so, create a new node that is a DISTINCT operation.
+  */
+  if(distinct && (root->node_type != qntDistinct))
+  {
+    int i;
+    pNode = (query_node*)my_malloc(sizeof(query_node), 
+            MYF(MY_ZEROFILL | MY_WME));
+    init_node(pNode);
+    pNode->sub_query = 0;
+    pNode->attributes = 0;
+    pNode->join_cond = jcUN;  /* (join_con_type) 0; */
+    pNode->join_type = jnUNKNOWN;  /* (type_join) 0; */
+    pNode->left = root;
+    pNode->right = 0;
+    for(i = 0; i < MAXNODETABLES; i++)
+      pNode->relations[i] = NULL;
+    pNode->nodeid = 90125;
+    pNode->child = LEFTCHILD;
+    root->parent_nodeid = 90125;
+    root->child = LEFTCHILD;
+    pNode->parent_nodeid = -1;
+    pNode->node_type = qntDistinct;
+    pNode->attributes = new Attribute();
+    pNode->where_expr = new Expression();
+    pNode->join_expr = new Expression();
+    root = pNode;
+  }
+  DBUG_RETURN(0);
+}
+
+/*
+  Prune the tree of dead limbs.
+
+  SYNOPSIS
+    prune_tree()
+    query_node *prev IN the previous node (parent)
+    query_node *cur_node IN the current node pointer (used to delete).
+
+  DESCRIPTION
+    This method looks for nodes blank nodes that are a result of performing
+    heuristic optimization on the tree and deletes them.
+
+  NOTES
+    This is a RECURSIVE method!
+
+  RETURN VALUE
+    Success = 0
+    Failed = 1
+*/
+int Query_tree::prune_tree(query_node *prev, query_node *cur_node)
+{
+  DBUG_ENTER("prune_tree");
+  if(cur_node != 0)
+  {
+    /* 
+      Blank Nodes are 1) projections without attributes 
+      that have at least 1 child, or 2) restrictions 
+      without expressions
+    */
+    if((((cur_node->node_type == qntProject) && 
+       (cur_node->attributes->num_attributes() == 0)) ||
+      ((cur_node->node_type == qntRestrict) && 
+       (cur_node->where_expr->num_expressions() == 0))) &&
+       ((cur_node->left == 0) || (cur_node->right == 0)))
+    {
+      /* 
+        Redirect the pointers for the nodes above and
+        below this node in the tree.
+      */
+      if(prev == 0) 
+      {
+         if(cur_node->left == 0)
+        {
+          cur_node->right->parent_nodeid = -1;
+          root = cur_node->right;
+        }
+        else
+        {
+          cur_node->left->parent_nodeid = -1;
+          root = cur_node->left;
+        }
+        my_free(cur_node);
+        cur_node = root;
+      }
+      else
+      {
+        if(prev->left == cur_node)
+        {
+          if(cur_node->left == 0)
+          {
+            prev->left = cur_node->right;
+            if (cur_node->right != NULL)
+              cur_node->right->parent_nodeid = prev->nodeid;
+          }
+          else
+          {
+            prev->left = cur_node->left;
+            if (cur_node->left != NULL)
+              cur_node->left->parent_nodeid = prev->nodeid;
+          }
+          my_free(cur_node);
+          cur_node = prev->left;
+        }
+        else
+        {
+          if(cur_node->left == 0)
+          {
+            prev->right = cur_node->right;
+            if (cur_node->right != NULL)
+              cur_node->right->parent_nodeid = prev->nodeid;
+          }
+          else
+          {
+            prev->right = cur_node->left;
+            if (cur_node->left != NULL)
+              cur_node->left->parent_nodeid = prev->nodeid;
+          }
+          my_free(cur_node);
+          cur_node = prev->right;
+        }
+      }
+      prune_tree(prev, cur_node);
+    }
+    else
+    {
+      prune_tree(cur_node, cur_node->left);
+      prune_tree(cur_node, cur_node->right);
+    }
+  }
+  DBUG_RETURN(0);
+}
+
+
+/*
+  Find a projection in the tree
+
+  SYNOPSIS
+    find_projection()
+    query_node *QN IN the node to operate on
+
+  DESCRIPTION
+    This method looks for a node containing a projection and returns the node
+    pointer.
+
+  NOTES
+    This finds the first projection and is biased to the left tree.
+    This is a RECURSIVE method!
+
+  RETURN VALUE
+    Success = query_node * the node located or NULL for not found
+    Failed = NULL
+*/
+Query_tree::query_node *Query_tree::find_projection(query_node *QN)
+{
+  DBUG_ENTER("find_projection");
+  query_node   *N;
+
+  N = 0;
+  if(QN != 0)
+  {
+    /* 
+      A projection is a node marked as project and 
+      has at least one attribute
+    */
+    if((QN->node_type == qntProject) &&
+       (QN->attributes != 0))
+      N = QN;
+    else
+    {
+      N = find_projection(QN->left);
+      if(N == 0)
+        N = find_projection(QN->right);
+    }
+  }
+  DBUG_RETURN(N);
+}
+
+/*
+  Push projections down the tree.
+
+  SYNOPSIS
+    push_projections()
+    query_node *QN IN the node to operate on
+    query_node *pNode IN the node containing the projection attributes
+
+  DESCRIPTION
+    This method looks for projections and pushes them down the tree to nodes
+    that contain the relations specified.
+
+  NOTES
+    This is a RECURSIVE method!
+
+  RETURN VALUE
+    Success = 0
+    Failed = 1
+*/
+int Query_tree::push_projections(query_node *QN, query_node *pNode)
+{
+  DBUG_ENTER("push_projections");
+  Item *   a;
+  int         i;
+  int         j;
+
+  if((QN != 0) && (pNode != 0))
+  {
+    if((QN->nodeid != pNode->nodeid) &&
+       (QN->node_type == qntProject))
+    {
+      i = 0;
+      j = QN->attributes->num_attributes();
+      
+      /* move attributes to new node */
+      while(i < j)
+      {
+        a = QN->attributes->get_attribute(i);
+        if(has_relation(QN, 
+          (char *)((Field *)a)->table->s->table_name.str))
+        {
+          if(!has_attribute(QN, a))
+            insert_attribute(QN, a);
+          del_attribute(pNode, a);
+        }
+        i++;
+      }
+    }
+    if(pNode->attributes->num_attributes() != 0)
+    {
+      push_projections(QN->left, pNode);
+      push_projections(QN->right, pNode);
+    }
+  }
+  DBUG_RETURN(0);
+}
+
+/*
+  Delete an attribute from a node.
+
+  SYNOPSIS
+    del_attribute()
+    query_node *QN IN the node to operate on
+    Item *a IN the attribute to remove
+
+  DESCRIPTION
+    This method removes the attribute specified.
+
+  RETURN VALUE
+    Success = 0
+    Failed = 1
+*/
+int Query_tree::del_attribute(query_node *QN, Item *a)
+{
+  DBUG_ENTER("del_attribute(query_node *QN, Item * a)");
+  if(QN != 0)
+  {
+    QN->attributes->remove_attribute(QN->attributes->index_of(
+      (char *)((Field *)a)->table->s->table_name.str,
+      (char *)((Field *)a)->field_name));
+  }
+  DBUG_RETURN(0);
+}
+
+/*
+  Check to see if the node has the table.
+
+  SYNOPSIS
+    has_relation()
+    query_node *QN IN the node to operate on
+    char *Table IN the relation you're looking for
+
+  DESCRIPTION
+    This method returns TRUE if the node contains the relation specified.
+
+  RETURN VALUE
+    Success = true
+    Failed = false
+*/
+bool Query_tree::has_relation(query_node *QN, char *table)
+{
+  DBUG_ENTER("has_relation(query_node *QN, char *Table)");
+  bool    found = false;
+  int     i = 0;
+
+  if(QN != 0)
+  {
+    while((QN->relations[i] != NULL) && (table != NULL))
+    {
+      if(strcmp(QN->relations[i]->table_name, table) == 0)
+        found = true;
+      i++;
+    }
+  }
+  DBUG_RETURN(found);
+}
+
+/*
+  Check to see if the node has the attribute.
+
+  SYNOPSIS
+    has_attribute()
+    query_node *QN IN the node to operate on
+    Item *a IN the attribute you're looking for
+
+  DESCRIPTION
+    This method returns TRUE if the node contains the attribute specified.
+
+  RETURN VALUE
+    Success = true
+    Failed = false
+*/
+bool Query_tree::has_attribute(query_node *QN, Item *a)
+{
+  DBUG_ENTER("has_attribute");
+  bool        found = false;
+  int         i = -1;
+
+  if(QN != 0)
+  {
+    i = QN->attributes->index_of(
+      (char *)((Field *)a)->table->s->table_name.str,
+      (char *)((Field *)a)->field_name);
+    if(i >= 0)
+      found = true;
+  }
+  DBUG_RETURN(found);
+}
+
+/*
+  Is the node a leaf?
+
+  SYNOPSIS
+    is_leaf()
+    query_node *QN IN the node to operate on
+
+  DESCRIPTION
+    This method returns TRUE if the node specified is a leaf (no children).
+
+  RETURN VALUE
+    Success = true
+    Failed = false
+*/
+bool Query_tree::is_leaf(query_node *QN)
+{
+  DBUG_ENTER("is_leaf");
+  DBUG_RETURN((QN->left == 0) && (QN->right == 0));
+}
+
+/*
+  Insert an attribute into the node.
+
+  SYNOPSIS
+    insert_attribute()
+    query_node *QN IN the node to operate on
+    Item *c IN the attribute to add
+
+  DESCRIPTION
+    This method is used to place an attribute (c) in the query node (QN).
+
+  RETURN VALUE
+    Success = 0
+    Failed = 1
+*/
+int Query_tree::insert_attribute(query_node *QN, Item *c)
+{
+  DBUG_ENTER("insert_attribute");
+  if(QN != 0)
+    QN->attributes->add_attribute(true, c);
+  DBUG_RETURN(0);
+}
+
+/*
+  Find a restriction in the subtree.
+  
+  SYNOPSIS
+    find_restriction()
+    query_node *QN IN the node to operate on
+
+  DESCRIPTION
+    This method looks for a node containing a restriction and returns the node
+    pointer.
+
+  NOTES
+    This is a RECURSIVE method!
+    This finds the first restriction and is biased to the left tree.
+
+  RETURN VALUE
+    Success = query_node * the node located
+    Failed = NULL
+*/
+Query_tree::query_node *Query_tree::find_restriction(query_node *QN)
+{
+  DBUG_ENTER("find_restriction");
+  query_node   *N;
+
+  N = 0;
+  if(QN != 0)
+  {
+    /* 
+      A restriction is a node marked as restrict and 
+      has at least one expression
+    */
+    if (QN->where_expr->num_expressions() > 0)
+      N = QN;
+    else
+    {
+      N = find_restriction(QN->left);
+      if(N == 0)
+        N = find_restriction(QN->right);
+    }
+  }
+  DBUG_RETURN(N);
+}
+
+/*
+  Push restrictions down the tree.
+
+  SYNOPSIS
+    push_restrictions()
+    query_node *QN IN the node to operate on
+    query_node *pNode IN the node containing the restriction attributes
+
+  DESCRIPTION
+    This method looks for restrictions and pushes them down the tree to nodes
+    that contain the relations specified.
+
+  NOTES
+    This is a RECURSIVE method!
+    This finds the first restriction and is biased to the left tree.
+
+  RETURN VALUE
+    Success = 0
+    Failed = 1
+*/
+int Query_tree::push_restrictions(query_node *QN, query_node *pNode)
+{
+  query_node *NewQN=0;
+
+  DBUG_ENTER("push_restrictions");
+  if((QN != 0) && (pNode != 0) && (pNode->left != 0))
+  {
+    /*
+      Conditions:
+        1) QN is a join node
+        2) QN is a project node
+        3) QN is a restrict node 
+        4) All other nodes types are ignored.
+      
+      Methods:
+        1) if join or project and the children are not already restrictions
+           add a new node and put where clause in new node else
+           see if you can combine the child node and this one
+        2) if the node has the table and it is a join,
+           create a new node below it and push the restriction
+           to that node.
+        4) if the node is a restriction and has the table,
+           just add the expression to the node's expression list
+    */
+
+    /* if projection, move node down tree */
+    if((QN->nodeid != pNode->nodeid) && (QN->node_type == qntProject))
+    {
+      if (QN->left != 0)
+      {
+        QN->left = (query_node*)my_malloc(sizeof(query_node), 
+                   MYF(MY_ZEROFILL | MY_WME));
+        init_node(QN->left);
+        NewQN = QN->left;
+        NewQN->left = 0;
+      }
+      else
+      {
+        NewQN = QN->left;
+        QN->left = (query_node*)my_malloc(sizeof(query_node), 
+                   MYF(MY_ZEROFILL | MY_WME));
+        QN->left->left = NewQN;
+        NewQN = QN->left;
+      }
+      NewQN->sub_query = 0;
+      NewQN->join_cond = jcUN;  /* (join_con_type) 0; */
+      NewQN->join_type = jnUNKNOWN;  /* (type_join) 0; */
+      NewQN->right = 0;
+      for(long i = 0; i < MAXNODETABLES; i++)
+        NewQN->relations[i] = 0;
+      NewQN->nodeid = QN->nodeid + 1;
+      NewQN->parent_nodeid = QN->nodeid;
+      NewQN->node_type = qntRestrict;
+      NewQN->attributes = new Attribute();
+      NewQN->where_expr = new Expression();
+      NewQN->join_expr = new Expression();
+      if (pNode->relations[0])
+        NewQN->where_expr->reduce_expressions(pNode->relations[0]->table);
+      if ((QN->relations[0] != NULL) && (QN->relations[0] == pNode->relations[0]))
+      {
+        if (QN->relations[0])
+          if (find_table_in_expr(pNode->where_expr, QN->relations[0]->table_name))
+          {
+            NewQN->relations[0] = QN->relations[0];
+            QN->relations[0] = 0;
+          }
+      }
+      else 
+      {
+        if (pNode->relations[0])
+          if (find_table_in_tree(QN->left, pNode->relations[0]->table_name))
+            NewQN->relations[0] = 0;
+        pNode->where_expr = NULL;
+        pNode->relations[0] = 0;
+      }
+    }
+    /* if join, move restrict node down tree */
+    else if((QN->nodeid != pNode->nodeid) && 
+      ((QN->left == 0) || (QN->right == 0)) &&
+      (QN->node_type == qntJoin))
+    {
+      if(QN->relations[0] != 0)
+      {
+        QN->left = (query_node*)my_malloc(sizeof(query_node), 
+                   MYF(MY_ZEROFILL | MY_WME));
+        NewQN = QN->left;
+        NewQN->sub_query = 0;
+        NewQN->join_cond = jcUN;  /* (join_con_type) 0; */
+        NewQN->join_type = jnUNKNOWN;  /* (type_join) 0; */
+        NewQN->left = 0;
+        NewQN->right = 0;
+        for(long i = 0; i < MAXNODETABLES; i++)
+          NewQN->relations[i] = 0;
+        NewQN->nodeid = QN->nodeid + 1;
+        NewQN->parent_nodeid = QN->nodeid;
+        NewQN->node_type = qntRestrict;
+        NewQN->attributes = new Attribute();
+        NewQN->where_expr = new Expression();
+        NewQN->join_expr = new Expression();
+        NewQN->relations[0] = QN->relations[0];
+        QN->relations[0] = 0;
+        if (pNode->relations[0])
+          NewQN->where_expr->reduce_expressions(pNode->relations[0]->table);
+      }
+      else if(QN->relations[1] != 0)
+      {
+        QN->right = (query_node*)my_malloc(sizeof(query_node), 
+                    MYF(MY_ZEROFILL | MY_WME));
+        NewQN = QN->left;
+        NewQN->sub_query = 0;
+        NewQN->join_cond = jcUN;  /* (join_con_type) 0; */
+        NewQN->join_type = jnUNKNOWN;  /* (type_join) 0; */
+        NewQN->left = 0;
+        NewQN->right = 0;
+        for(long i = 0; i < MAXNODETABLES; i++)
+          NewQN->relations[i] = 0;
+      }
+      NewQN->nodeid = QN->nodeid + 1;
+      NewQN->parent_nodeid = QN->nodeid;
+      NewQN->node_type = qntRestrict;
+      NewQN->attributes = new Attribute();
+      NewQN->where_expr = new Expression();
+      NewQN->join_expr = new Expression();
+      NewQN->relations[0] = QN->relations[1];
+      QN->relations[1] = 0;
+      NewQN->where_expr->reduce_expressions(pNode->relations[0]->table);
+    }
+    push_restrictions(QN->left, pNode);
+    push_restrictions(QN->right, pNode);
+  }
+   DBUG_RETURN(0);
+}
+
+/*
+  Find a join in the subtree.
+  
+  SYNOPSIS
+    find_restriction()
+    query_node *QN IN the node to operate on
+
+  DESCRIPTION
+    This method looks for a node containing a join and returns the 
+    node pointer.
+
+  NOTES
+    This is a RECURSIVE method!
+    This finds the first restriction and is biased to the left tree.
+
+  RETURN VALUE
+    Success = query_node * the node located
+    Failed = NULL
+*/
+Query_tree::query_node *Query_tree::find_join(query_node *QN)
+{
+  DBUG_ENTER("find_join");
+  query_node               *N;
+  N = 0;
+
+  if(QN != 0)
+  {
+    /* 
+      if this is a restrict node or a restrict node with 
+      at least one expression it could be an unprocessed join
+      because the default node type is restrict
+    */
+    if(((QN->node_type == qntRestrict) ||
+      (QN->node_type == qntRestrict)) && (QN->join_expr->num_expressions() > 0))
+      N = QN;
+    else
+    {
+      N = find_join(QN->left);
+      if(N == 0)
+        N = find_join(QN->right);
+    }
+  }
+  DBUG_RETURN(N);
+}
+
+/*
+  Push joins down the tree.
+
+  SYNOPSIS
+    push_restrictions()
+    query_node *QN IN the node to operate on
+    query_node *pNode IN the node containing the join
+
+  DESCRIPTION
+    This method looks for theta joins and pushes them down the tree to the 
+    parent of two nodes that contain the relations specified.
+
+  NOTES
+    This is a RECURSIVE method!
+
+  RETURN VALUE
+    Success = 0
+    Failed = 1
+*/
+int Query_tree::push_joins(query_node *QN, query_node *pNode)
+{
+  DBUG_ENTER("push_joins");
+  Item *lField;
+  Item *rField;
+  expr_node *node;
+  
+  if(!pNode->join_expr)
+    DBUG_RETURN(0);
+  node = pNode->join_expr->get_expression(0);
+  if (!node)
+    DBUG_RETURN(0);
+  lField = node->left_op;
+  rField = node->right_op;
+
+  /* Node must have expressions and not be null */
+  if((QN != NULL) && (pNode != NULL) && 
+     (pNode->join_expr->num_expressions() > 0))
+  {
+    /* check to see if tables in join condition exist */
+    if((QN->nodeid != pNode->nodeid) &&
+       (QN->node_type == qntJoin) &&
+        QN->join_expr->num_expressions() == 0 &&
+       ((has_relation(QN->left, 
+         (char *)((Field *)lField)->table->s->table_name.str) &&
+       has_relation(QN->right, 
+         (char *)((Field *)rField)->table->s->table_name.str)) ||
+      (has_relation(QN->left, 
+        (char *)((Field *)rField)->table->s->table_name.str) && 
+       has_relation(QN->right, 
+         (char *)((Field *)lField)->table->s->table_name.str))))
+    {
+      /* move the expression */
+      QN->join_expr = pNode->join_expr;
+      pNode->join_expr = new Expression();
+      QN->join_type = jnINNER;
+      QN->join_cond = jcON;
+    }
+    push_joins(QN->left, pNode);
+    push_joins(QN->right, pNode);
+  }
+  DBUG_RETURN(0);
+}
+
+/*
+  Balance multiway joins to place most restrictive joins at lower level.
+
+  SYNOPSIS
+    balance_joins()
+    query_node *QN IN the node to operate on
+
+  DESCRIPTION
+    This method will balance the joins once cost-based factors are applied.
+
+  RETURN VALUE
+    Success = 0
+    Failed = 1
+*/
+int Query_tree::balance_joins(query_node *QN)
+{
+  DBUG_ENTER("balance_joins");
+  DBUG_RETURN(0);
+}
+
+/*
+  Perform cost optimization on the query tree.
+
+  SYNOPSIS
+    cost_optimization()
+
+  DESCRIPTION
+    This method performs cost-based optimization on the query tree. The 
+    operation is nondestructive.
+
+  RETURN VALUE
+    Success = 0
+    Failed = 1
+*/
+int Query_tree::cost_optimization()
+{
+  DBUG_ENTER("cost_optimization");
+  c_opt = true;
+
+  balance_joins(root);
+  apply_indexes(root);
+  DBUG_RETURN(0);
+}
+
+/*
+  Walk the tree and choose best indexes for table access.
+
+  SYNOPSIS
+    apply_indexes()
+    query_node *QN IN the node to operate on
+
+  DESCRIPTION
+    Search the tree looking for all possible indexes that can be used 
+    and apply them to the SelIndex variable(s);
+
+  RETURN VALUE
+    Success = 0
+    Failed = 1
+*/
+int Query_tree::apply_indexes(query_node *QN)
+{
+  DBUG_ENTER("apply_indexes");
+  DBUG_RETURN(0);
+}
+
+/*
+  Split restrictions that have attributes (projections).
+
+  SYNOPSIS
+    split_restrict_with_project()
+    query_node *QN IN the node to operate on
+
+  DESCRIPTION
+    This method looks for restrictions that have attributes (thus are both
+    projections and restrictions) and breaks them into two nodes.
+
+  NOTES
+    This is a RECURSIVE method!
+
+  RETURN VALUE
+    Success = 0
+    Failed = 1
+*/
+int Query_tree::split_restrict_with_project(query_node *QN)
+{
+  DBUG_ENTER("split_restrict_with_project");
+  if(QN != 0)
+  {
+    if(((QN->attributes->num_attributes() > 0) &&
+      (QN->where_expr->num_expressions() > 0)) &&
+      ((QN->node_type == qntProject) || (QN->node_type == qntRestrict)))
+    {
+      /*
+        Create a new node and:
+          1) Move the expressions to the new node.
+          2) Set the new node's children = current node children
+          3) Set the new node's relations = current node relations.
+          4) Set current node's left child = new node;
+          5) Set new node's id = current id + 1000;
+          6) set parent id, etc.
+      */
+      query_node *new_node = (query_node*)my_malloc(sizeof(query_node), 
+                             MYF(MY_ZEROFILL | MY_WME));
+      init_node(new_node);
+      new_node->child = LEFTCHILD;
+      new_node->node_type = qntRestrict;
+      if(new_node->node_type == qntJoin)
+      {
+        new_node->join_cond = QN->join_cond;
+        new_node->join_type = QN->join_type;
+      }
+      QN->node_type = qntProject;
+      new_node->attributes = new Attribute();
+      new_node->where_expr = QN->where_expr;
+      new_node->join_expr = new Expression();
+      QN->where_expr = new Expression();
+      new_node->left = QN->left;
+      new_node->right = QN->right;
+      new_node->parent_nodeid = QN->nodeid;
+      new_node->nodeid = QN->nodeid + 1000;
+      if(new_node->left)
+        new_node->left->parent_nodeid = new_node->nodeid;
+      if(new_node->right)
+        new_node->right->parent_nodeid = new_node->nodeid;
+      for(int i = 0; i < MAXNODETABLES; i++)
+      {
+        new_node->relations[i] = QN->relations[i];
+        QN->relations[i] = NULL;
+      }
+      QN->left = new_node;
+      QN->right = 0;
+    }
+    split_restrict_with_project(QN->left);
+    split_restrict_with_project(QN->right);
+  }
+  DBUG_RETURN(0);
+}
+
+/*  
+  Split restrictions that have joins.
+
+  SYNOPSIS
+    split_restrict_with_join()
+    query_node *QN IN the node to operate on
+
+  DESCRIPTION
+     This method looks for joins that have where expressions (thus are both
+     joins and restrictions) and breaks them into two nodes.
+
+  NOTES
+    This is a RECURSIVE method!
+
+  RETURN VALUE
+    Success = 0
+    Failed = 1
+*/
+int Query_tree::split_restrict_with_join(query_node *QN)
+{
+  int j = 0;
+  int i = 0;
+
+  DBUG_ENTER("split_restrict_with_join");
+  if(QN != 0)
+  {
+    if(((QN->join_expr->num_expressions() > 0) &&
+      (QN->where_expr->num_expressions() > 0)) &&
+       ((QN->node_type == qntJoin) || (QN->node_type == qntRestrict)))
+    {
+      bool isleft = true;
+      /*
+        Create a new node and:
+          1) Move the where expressions to the new node.
+          2) Set the new node's children = current node children
+          3) Set the new node's relations = current node relations.
+          4) Set current node's left or right child = new node;
+          5) Set new node's id = current id + 200;
+           6) set parent id, etc.
+          7) determine which table needs to be used for the 
+             restrict node.
+      */
+      query_node *new_node = (query_node*)my_malloc(sizeof(query_node), 
+                             MYF(MY_ZEROFILL | MY_WME));
+      init_node(new_node);
+      new_node->node_type = qntRestrict;
+      new_node->parent_nodeid = QN->nodeid;
+      new_node->nodeid = QN->nodeid + 200;
+      new_node->where_expr = QN->where_expr;
+      new_node->join_expr = new Expression();
+      QN->where_expr = new Expression();
+
+      /* 
+        Loop through tables and move table that matches
+        to the new node
+      */
+      for(i = 0; i < MAXNODETABLES; i++)
+      {
+        if (QN->relations[i] != NULL)
+        {
+          if (find_table_in_expr(new_node->where_expr, 
+                QN->relations[i]->table_name))
+          {
+            new_node->relations[j] = QN->relations[i];
+            j++;
+            if (i != 0)
+              isleft = false;
+            QN->relations[i] = NULL;
+          }
+        }
+      }
+
+      /* set children to point to balance of tree */
+      new_node->right = 0;
+      if (isleft)
+      {
+        new_node->child = LEFTCHILD;
+        new_node->left = QN->left;
+        QN->left = new_node;
+      }
+      else
+      {
+        new_node->child = RIGHTCHILD;
+        new_node->left = QN->right;
+        QN->right = new_node;
+      }
+      if (new_node->left)
+        new_node->left->parent_nodeid = new_node->nodeid;
+      j = QN->attributes->num_attributes(); 
+      if ((QN->node_type == qntJoin) && (j > 0))
+      {
+        Attribute *attribs = 0;
+        Item * attr;
+        int ii = 0;
+        int jj = 0;
+        if ((QN->attributes->num_attributes() == 1) &&
+            (strcasecmp("*", 
+            ((Field *)QN->attributes->get_attribute(0))->field_name) == 0))
+        {
+          new_node->attributes = new Attribute();
+          new_node->attributes->add_attribute(j, 
+            QN->attributes->get_attribute(0));
+        }
+        else
+        {
+          attribs = new Attribute();
+          for (i = 0; i < (int)new_node->relations[0]->table->s->fields; i++)
+          {
+            Item *f = (Item *)new_node->relations[0]->table->field[i];
+            attribs->add_attribute(true, (Item *)f);
+          }
+          j = attribs->num_attributes();
+          new_node->attributes = new Attribute();
+          for (i = 0; i < j; i++)
+          {
+            attr = attribs->get_attribute(i);
+            jj = QN->attributes->index_of(
+              (char *)((Field *)attr)->table->s->table_name.str, 
+              (char *)((Field *)attr)->field_name);
+            if (jj > -1)
+            {
+              new_node->attributes->add_attribute(ii, attr);
+              ii++;
+              QN->attributes->remove_attribute(jj);
+            }
+            else if (find_attr_in_expr(QN->join_expr, 
+             (char *)((Field *)attr)->table->s->table_name.str, 
+             (char *)((Field *)attr)->field_name)) 
+            {
+              new_node->attributes->add_attribute(ii, attr);
+              new_node->attributes->hide_attribute(attr, true);
+              ii++;
+            }
+          }
+        }
+      }
+      else
+      {
+        QN->node_type = qntJoin;
+        QN->join_type = jnINNER;
+        new_node->attributes = new Attribute();
+      }
+    }
+    split_restrict_with_join(QN->left);
+    split_restrict_with_join(QN->right); 
+  }
+  DBUG_RETURN(0);
+}
+
+/*
+  Split projections that have joins.
+
+  SYNOPSIS
+    split_project_with_join()
+    query_node *QN IN the node to operate on
+
+  DESCRIPTION
+     This method looks for joins that have attributes (thus are both
+     joins and projections) and breaks them into two nodes.
+
+  NOTES
+    This is a RECURSIVE method!
+
+  RETURN VALUE
+    Success = 0
+    Failed = 1
+*/
+int Query_tree::split_project_with_join(query_node *QN)
+{
+  int j = 0;
+  int i;
+
+  DBUG_ENTER("split_project_with_join");
+  if(QN != 0)
+  {
+    if((QN->join_expr->num_expressions() > 0) &&
+       ((QN->node_type == qntJoin) || (QN->node_type == qntProject)))
+    {
+      /*
+        Create a new node and:
+          1) Move the where expressions to the new node.
+          2) Set the new node's children = current node children
+          3) Set the new node's relations = current node relations.
+          4) Set current node's left or right child = new node;
+          5) Set new node's id = current id + 300;
+          6) set parent id, etc.
+      */
+      QN->node_type = qntJoin;
+      QN->join_type = jnINNER;
+      if (QN->left == 0)
+      {
+        query_node *new_node = (query_node*)my_malloc(sizeof(query_node), 
+                               MYF(MY_ZEROFILL | MY_WME));
+        init_node(new_node);
+        new_node->node_type = qntProject;
+        new_node->parent_nodeid = QN->nodeid;
+        new_node->nodeid = QN->nodeid + 300;
+        for(i = 0; i < MAXNODETABLES; i++)
+          new_node->relations[i] = 0;
+        new_node->relations[0] = QN->relations[0];
+        QN->relations[0] = 0;
+        new_node->left = QN->left;
+        QN->left = new_node;
+        new_node->right = 0;
+        new_node->child = LEFTCHILD;
+        if (new_node->left != 0)
+           new_node->left->parent_nodeid = new_node->nodeid;
+        j = QN->attributes->num_attributes();
+        new_node->attributes = new Attribute();
+        new_node->where_expr = new Expression();
+        new_node->join_expr = new Expression();
+        if ((j == 1) &&
+            (strcasecmp("*", ((Field *)QN->attributes->get_attribute(0))->field_name)==0))
+        {
+          new_node->attributes = new Attribute();
+          new_node->attributes->add_attribute(j, QN->attributes->get_attribute(0));
+          if (QN->right != 0)
+            QN->attributes->remove_attribute(0);
+        }
+        else if (j > 0)
+        {
+          Attribute *attribs = 0;
+          Item * attr;
+          int ii = 0;
+          int jj = 0;
+          attribs = new Attribute();
+          for (i = 0; i < (int)new_node->relations[0]->table->s->fields; i++)
+          {
+            Field *f = new_node->relations[0]->table->field[i];
+            attribs->add_attribute(true, (Item *)f);
+          }
+          j = attribs->num_attributes();
+          for (i = 0; i < j; i++)
+          {
+            attr = attribs->get_attribute(i);
+            jj = QN->attributes->index_of(
+              (char *)((Field *)attr)->table->s->table_name.str, 
+              (char *)((Field *)attr)->field_name);
+            if (jj > -1)
+            {
+              new_node->attributes->add_attribute(ii, attr);
+              ii++;
+              QN->attributes->remove_attribute(jj);
+            }
+            else if (find_attr_in_expr(QN->join_expr, 
+              (char *)((Field *)attr)->table->s->table_name.str, 
+              (char *)((Field *)attr)->field_name)) 
+            {
+              new_node->attributes->add_attribute(ii, attr);
+              new_node->attributes->hide_attribute(attr, true);
+              ii++;
+            }
+          }
+        }
+      }
+      if (QN->right == 0)
+      {
+        query_node *new_node = (query_node*)my_malloc(sizeof(query_node), 
+                               MYF(MY_ZEROFILL | MY_WME));
+        init_node(new_node);
+        new_node->node_type = qntProject;
+        new_node->parent_nodeid = QN->nodeid;
+        new_node->nodeid = QN->nodeid + 400;
+        for(i = 0; i < MAXNODETABLES; i++)
+          new_node->relations[0] = 0;
+        new_node->relations[0] = QN->relations[1];
+        QN->relations[1] = 0;
+        new_node->left = QN->right;
+        QN->right = new_node;
+        new_node->right = 0;
+        new_node->child = RIGHTCHILD;
+        if (new_node->left != 0)
+          new_node->left->parent_nodeid = new_node->nodeid;
+        j = QN->attributes->num_attributes();
+        new_node->attributes = new Attribute();
+        new_node->where_expr = new Expression();
+        new_node->join_expr = new Expression();
+        if ((j == 1) &&
+            (strcasecmp("*", ((Field *)QN->attributes->get_attribute(0))->field_name)==0))
+        {
+          new_node->attributes = new Attribute();
+          new_node->attributes->add_attribute(j, QN->attributes->get_attribute(0));
+          QN->attributes->remove_attribute(0);
+        }
+        else
+        {
+          Attribute *attribs = 0;
+          Item * attr;
+          int ii = 0;
+          int jj = 0;
+          attribs = new Attribute();
+          for (i = 0; i < (int)new_node->relations[0]->table->s->fields; i++)
+          {
+            Field *f = new_node->relations[0]->table->field[i];
+            attribs->add_attribute(true, (Item *)f);
+            if (j == 0)
+            {
+              new_node->attributes->hide_attribute((Item *)f, true);
+            }
+          }
+          j = attribs->num_attributes();
+          new_node->attributes = new Attribute();
+          for (i = 0; i < j; i++)
+          {
+            attr = attribs->get_attribute(i);
+            jj = QN->attributes->index_of(
+              (char *)((Field *)attr)->table->s->table_name.str, 
+              (char *)((Field *)attr)->field_name);
+            if (jj > -1)
+            {
+              new_node->attributes->add_attribute(ii, attr);
+              ii++;
+              QN->attributes->remove_attribute(jj);
+            }
+            else if (find_attr_in_expr(QN->join_expr, 
+              (char *)((Field *)attr)->table->s->table_name.str, 
+              (char *)((Field *)attr)->field_name)) 
+            {
+              new_node->attributes->add_attribute(ii, attr);
+              new_node->attributes->hide_attribute(attr, true);
+              ii++;
+            }
+          }
+        }
+      }
+    }
+    split_project_with_join(QN->left);
+    split_project_with_join(QN->right);
+  }
+  DBUG_RETURN(0);
+}
+
+/*
+  Find a table in the tree.
+
+  SYNOPSIS
+    find_table_in_tree()
+    query_node *QN IN the node to operate on
+    char *tbl IN the table to locate
+
+  DESCRIPTION
+    This method looks for the table name passed in the expressions
+    of the tree nodes.
+
+  RETURN VALUE
+    Success = true
+    Failed = false
+*/
+bool Query_tree::find_table_in_tree(query_node *QN, char *tbl)
+{
+  DBUG_ENTER("find_table_in_tree");
+  bool found = false;
+
+  if (QN != 0)
+    if (QN->where_expr->num_expressions() > 0)
+      if (find_table_in_expr(QN->where_expr, tbl))
+        found = true;
+  if (!found)
+    found = find_table_in_tree(QN->left, tbl);
+  if (!found)
+    found = find_table_in_tree(QN->right, tbl);
+  DBUG_RETURN(found);
+}
+
+/*
+  Find a table in the expression.
+
+  SYNOPSIS
+    find_table_in_expr()
+    Expression *expr IN the expression to search
+    char *tbl IN the table to locate
+
+  DESCRIPTION
+    This method looks for the table name passed in the expressions
+    specified.
+
+  RETURN VALUE
+    Success = true
+    Failed = false
+*/
+bool Query_tree::find_table_in_expr(Expression *expr, char *tbl)
+{
+  DBUG_ENTER("find_table_in_expr");
+  DBUG_RETURN(expr->has_table(tbl));
+}
+
+/*
+  Find an attribute in the expression.
+
+  SYNOPSIS
+    find_attr_in_expr()
+    Expression *expr IN the expression to search
+    char *tbl IN the table to locate
+    char *value IN the name of the attribute
+
+  DESCRIPTION
+    This method looks for the attribute passed in the expression
+    specified.
+
+  RETURN VALUE
+    Success = true
+    Failed = false
+*/
+bool Query_tree::find_attr_in_expr(Expression *expr, char *tbl, char *value)
+{
+  DBUG_ENTER("find_attr_in_expr");
+  DBUG_RETURN(expr->index_of(tbl, value) > 0);
+}
+
+/*
+  Prepare the query tree for execution.
+
+  SYNOPSIS
+    prepare()
+    query_node *qn IN the operational node in the query tree.
+
+  DESCRIPTION
+    This method is used to open all of the relations used in the query and
+    to open the pipeline for execution.
+
+  NOTES
+    Walks the tree and start all of the iterators.
+    Call this first for each query run.
+
+  RETURN VALUE
+    Success = 0
+    Failed = 1
+*/
+int Query_tree::prepare(query_node *qn)
+{
+  int i;
+  int ndx;
+
+  DBUG_ENTER("prepare");
+  if (qn == root)
+  {
+    lbuff = NULL;
+    rbuff = NULL;
+  }
+  if (qn != NULL)
+  {
+    qn->preempt_pipeline = true;  
+    if (qn->node_type == (Query_tree::query_node_type) 1 )
+    {
+      for (i = 0; i < MAXNODETABLES; i++)
+        if (qn->relations[i] != NULL)
+        {
+          ndx = find_index_in_expr(qn->where_expr, qn->relations[i]->table_name);
+          if (ndx > -1)
+            qn->relations[i]->table->file->ha_index_init(ndx, true);
+          else
+            qn->relations[i]->table->file->ha_rnd_init(true);
+        }
+    }
+    else
+      for (i = 0; i < MAXNODETABLES; i++)
+        if (qn->relations[i] != NULL)
+            qn->relations[i]->table->file->ha_rnd_init(true);
+    prepare(qn->left);
+    prepare(qn->right);
+  }
+  DBUG_RETURN(0);
+}
+
+/*
+  Shutdown the reads after execution.
+
+  SYNOPSIS
+    cleanup()
+    query_node *qn IN the operational node in the query tree.
+
+  DESCRIPTION
+    This method is used to open all of the relations used in the query and
+    to open the pipeline for execution.
+
+  NOTES
+    Walks the tree and closes all of the iterators.
+    Call this last for each query run.
+
+  RETURN VALUE
+    Success = 0
+    Failed = 1
+*/
+int Query_tree::cleanup(query_node *qn)
+{
+  int i;
+
+  DBUG_ENTER("cleanup");
+  if (qn != NULL)
+  {
+      for (i = 0; i < MAXNODETABLES; i++)
+        if (qn->relations[i] != NULL)
+            qn->relations[i]->table->file->ha_index_or_rnd_end();
+    cleanup(qn->left);
+    cleanup(qn->right);
+  }
+  DBUG_RETURN(0);
+}
+
+/*
+  Get the next tuple (row) in the result set.
+
+  SYNOPSIS
+    Eof()
+    query_node *qn IN the operational node in the query tree.
+
+  DESCRIPTION
+    This method is used to get the next READ_RECORD from the pipeline.
+    The idea is to call prepare() after you've validated the query then call
+    get_next to get the first tuple in the pipeline.
+
+  RETURN VALUE
+    Success = next tuple in the result set
+    Failed = NULL
+*/
+READ_RECORD *Query_tree::get_next(query_node *qn)
+{
+  READ_RECORD *next_tup = NULL;
+  DBUG_ENTER("get_next");
+
+  /* 
+    For each of the possible node types, perform the query operation
+    by calling the method for the operation. These implement a very
+    high-level abstraction of the operation. The real work is left 
+    to the methods.
+  */
+  switch (qn->node_type)
+  {
+    /* placeholder for exercises... */
+    case Query_tree::qntDistinct :
+      break;
+
+    /* placeholder for exercises... */
+    case Query_tree::qntUndefined :
+      break;
+
+    /* placeholder for exercises... */
+    case Query_tree::qntSort :
+      if (qn->preempt_pipeline)
+        qn->preempt_pipeline = false;
+      break;
+
+    /* 
+      For restrict, get a row (tuple) from the table and 
+      call the do_restrict method looping until a row is returned
+      (data matches conditions), then return result to main loop 
+      in DBXP_select_command.
+    */
+    case Query_tree::qntRestrict :
+      do
+      {
+        /* if there is a child, get row from child */
+        if (qn->left != NULL)
+          next_tup = get_next(qn->left);
+
+        /* else get the row from the table stored in this node */
+        else
+        {
+          /* create space for the record buffer */
+          if (next_tup == NULL)
+            next_tup = (READ_RECORD *) my_malloc(sizeof(READ_RECORD),
+                                              MYF(MY_ZEROFILL | MY_WME));
+          next_tup->rec_buf = (uchar *) my_malloc(qn->relations[0]->table->s->rec_buff_length,
+                                            MYF(MY_ZEROFILL | MY_WME));
+
+          /* read row from table (storage handler */
+          qn->eof[0] = qn->relations[0]->table->file->ha_rnd_next(next_tup->rec_buf);
+   
+          /* check for end of file */
+          if (qn->eof[0] != HA_ERR_END_OF_FILE)
+            qn->eof[0] = false;
+          else
+          {
+            qn->eof[0] = true;
+            next_tup = NULL;
+          }
+        }
+
+        /* if there is a row, call the do_restrict method */
+        if (next_tup)
+          if(!do_restrict(qn, next_tup))
+          {
+            /* if no row to return, free memory used */
+            my_free(next_tup->rec_buf);
+            my_free(next_tup);
+            next_tup = NULL;
+          }
+      } while ((next_tup == NULL) && !Eof(qn));
+      break;
+
+    /* 
+      For project, get a row (tuple) from the table and 
+      call the do_project method. If successful, 
+      return result to main loop in DBXP_select_command.
+    */
+    case Query_tree::qntProject :
+      /* if there is a child, get row from child */
+      if (qn->left != NULL)
+      {
+        next_tup = get_next(qn->left);
+        if (next_tup)
+          if (!do_project(qn, next_tup))
+          {
+            /* if no row to return, free memory used */
+            my_free(next_tup->rec_buf);
+            my_free(next_tup);
+            next_tup = NULL;
+          }
+      }
+
+      /* else get the row from the table stored in this node */
+      else  
+      {
+        /* create space for the record buffer */
+        if (next_tup == NULL)
+          next_tup = (READ_RECORD *) my_malloc(sizeof(READ_RECORD),
+                                            MYF(MY_ZEROFILL | MY_WME));
+        next_tup->rec_buf = (uchar *) my_malloc(qn->relations[0]->table->s->rec_buff_length + 20,
+                                          MYF(MY_ZEROFILL | MY_WME));
+
+        /* read row from table (storage handler) */
+        qn->eof[0] = qn->relations[0]->table->file->ha_rnd_next(next_tup->rec_buf);
+   
+        /* check for end of file */
+        if (qn->eof[0] != HA_ERR_END_OF_FILE)
+        {
+          qn->eof[0] = false;
+        }
+        else
+        {
+          qn->eof[0] = true;
+          next_tup = NULL;
+        }
+
+        /* if there is a row, call the do_project method */
+        if (next_tup)
+        {
+          if (!do_project(qn, next_tup))
+          {
+            /* no row to return, free memory used */
+            my_free(next_tup->rec_buf);
+            my_free(next_tup);
+            next_tup = NULL;
+          }
+        }
+      }
+      break;
+
+    /* 
+      For join, loop until either a row is returned from the 
+      do_join method or we are at end of file for both tables. 
+      If successful (data matches conditions),
+      return result to main loop in DBXP_select_command.
+    */
+    case Query_tree::qntJoin :
+      do
+      {
+        if (next_tup)
+        {
+          /* if no row to return, free memory used */
+          my_free(next_tup->rec_buf);
+          my_free(next_tup);
+          next_tup = NULL;
+        }
+        next_tup = do_join(qn);
+      }
+      while ((next_tup == NULL) && !Eof(qn));
+      break;
+  }
+  DBUG_RETURN(next_tup);
+}
+
+/*
+  Check for end of file.
+
+  SYNOPSIS
+    Eof()
+    query_node *qn IN the operational node in the query tree.
+
+  DESCRIPTION
+    This method is used to determine if the query is complete and the
+    pipeline is empty (true). While false, this indicates either the
+    relations in the query are not at EOF or the pipeline is not empty.
+
+  NOTES
+    Premise: Nodes can have at most 2 relations.
+    The concept here is the left relation is in pos 0
+    and the right relation is in pos 1. In the case that
+    the left child exists, the left relation at pos 0 is
+    undefined. Likewise, if the right child exists, the
+    right relation at pos 1 is undefined.
+
+    For restrict & project, there should only ever be one
+    relation coming from the left child because the query
+    optimizer is left-child biased.
+
+  RETURN VALUE
+    Success = true: indicates pipeline is empty and query is complete
+    Failed = false
+*/
+bool Query_tree::Eof(query_node *qn)
+{
+  bool    end_of_file = true;
+  bool    end_of_file_left = true;
+  bool    end_of_file_right = true;
+
+  DBUG_ENTER("Eof");
+  switch (qn->node_type)
+  {
+    case Query_tree::qntSort :
+      break;
+    case Query_tree::qntDistinct :  
+      if (qn->relations[2] == NULL)
+        end_of_file = false;
+      else
+        end_of_file = qn->eof[2];
+      break;
+    case Query_tree::qntUndefined :  
+      end_of_file = true;
+      break;
+    case Query_tree::qntRestrict :  
+      if (qn->left != NULL)
+        end_of_file = Eof(qn->left);
+      else
+        end_of_file = qn->eof[0];
+      break;
+    case Query_tree::qntProject :
+    {
+      if (qn->left != NULL)
+        end_of_file = Eof(qn->left);
+      else
+        end_of_file = qn->eof[0];
+      break;
+    }
+    case Query_tree::qntJoin :
+      if ((qn->join_type == jnINNER) || (qn->join_type == jnLEFTOUTER) ||
+        (qn->join_type == jnRIGHTOUTER) || (qn->join_type == jnFULLOUTER))
+      {
+        if (qn->preempt_pipeline)
+          end_of_file = false;
+        else
+        {
+          end_of_file_left = qn->eof[2];
+          end_of_file_right = qn->eof[3];
+          end_of_file = end_of_file_left || end_of_file_right;
+          if (end_of_file)
+          {
+            record_buff *n;
+            /*
+              clean up buffers
+            */
+            left_record_buffer_ptr = left_record_buff;
+            while (left_record_buffer_ptr != NULL)
+            {
+              n = left_record_buffer_ptr;
+              my_free(n->field_ptr);
+              left_record_buffer_ptr = left_record_buffer_ptr->next;
+              my_free(n);
+            }
+            right_record_buffer_ptr = right_record_buff;
+            while (right_record_buffer_ptr != NULL)
+            {
+              n = right_record_buffer_ptr;
+              my_free(n->field_ptr);
+              right_record_buffer_ptr = right_record_buffer_ptr->next;
+              my_free(n);
+            }
+          }
+        }
+      }
+      else if ((qn->join_type == jnUNION) || (qn->join_type == jnINTERSECT))
+      {
+        if (qn->preempt_pipeline)
+          end_of_file = false;  
+        else          
+          end_of_file = qn->eof[2];
+      }
+      else if (qn->join_type == jnCROSSPRODUCT)  
+      {
+        if (qn->left != NULL)
+          end_of_file = Eof(qn->left);
+        else
+          end_of_file = qn->eof[0];
+      }
+      else
+      {
+        if (qn->left != NULL)
+          end_of_file_left = Eof(qn->left);
+        else
+          end_of_file_left = qn->eof[0];
+        if (qn->right != NULL)
+          end_of_file_right = Eof(qn->right);
+        else
+          end_of_file_right = qn->eof[1];
+        end_of_file = end_of_file_left && end_of_file_right;
+      }
+      break;
+  }
+  DBUG_RETURN(end_of_file);
+}
+
+/*
+  Perform restrict operation.
+
+  SYNOPSIS
+    do_restrict()
+    query_node *qn IN the operational node in the query tree.
+    READ_RECORD *t -- the tuple to apply the operation to.
+
+  DESCRIPTION
+    This method performs the relational model operation entitled "restrict".
+    This operation is a narrowing of the result set horizontally by
+    satisfying the expressions listed in the where clause of the SQL
+    statement being executed.
+
+  RETURN VALUE
+    Success = true
+    Failed = false
+*/
+bool Query_tree::do_restrict(query_node *qn, READ_RECORD *t)
+{
+  bool found = false;
+
+  DBUG_ENTER("do_restrict");
+  if (qn != NULL)
+  {
+    /* 
+       If the left table isn't NULL, copy the record buffer from
+       the table into the record buffer of the relations class.
+       This completes the read from the storage engine and now
+       provides the data for the projection (which is accomplished
+       in send_data().
+ 
+       Lastly, evaluate the where clause. If the where clause 
+       evaluates to true, we keep the record else we discard it.
+    */
+    if (qn->relations[0] != NULL)
+      memcpy((uchar *)qn->relations[0]->table->record[0], (uchar *)t->rec_buf, 
+        qn->relations[0]->table->s->rec_buff_length);
+    if (qn->where_expr != NULL)
+      found = qn->where_expr->evaluate(qn->relations[0]->table);
+  }
+  DBUG_RETURN(found);
+}
+
+/*
+  Perform project operation.
+
+  SYNOPSIS
+    do_project()
+    query_node *qn IN the operational node in the query tree.
+    READ_RECORD *t -- the tuple to apply the operation to.
+
+  DESCRIPTION
+    This method performs the relational model operation entitled "project".
+    This operation is a narrowing of the result set vertically by
+    restricting the set of attributes in the output tuple.
+
+  NOTES
+    Returns 0 (null) if no tuple satisfies child operation (does NOT indicate
+    the end of the file or end of query operation. Use Eof() to verify.
+
+  RETURN VALUE
+    Success = new tuple with correct attributes
+    Failed = NULL
+*/
+READ_RECORD *Query_tree::do_project(query_node *qn, READ_RECORD *t)
+{
+  DBUG_ENTER("do_project");
+  if (t != NULL)
+  {
+    if (qn == root)
+
+      /* 
+         If the left table isn't NULL, copy the record buffer from
+         the table into the record buffer of the relations class.
+         This completes the read from the storage engine and now
+         provides the data for the projection (which is accomplished
+         in send_data().
+      */
+      if (qn->relations[0] != NULL)
+        memcpy((uchar *)qn->relations[0]->table->record[0], 
+          (uchar *)t->rec_buf, 
+          qn->relations[0]->table->s->rec_buff_length);
+  }
+  DBUG_RETURN(t);
+}
+
+/*
+  Perform join operation.
+
+  SYNOPSIS
+    do_join()
+    query_node *qn IN the operational node in the query tree.
+    READ_RECORD *t -- the tuple to apply the operation to.
+
+  DESCRIPTION
+    This method performs the relational model operation entitled 
+    "join". This operation is the combination of two relations to 
+    form a composite view. This algorithm implements ALL variants
+    of the join operation.
+
+  NOTES
+    Returns 0 (null) if no tuple satisfies child operation (does 
+    NOT indicate the end of the file or end of query operation. 
+    Use Eof() to verify.
+
+  RETURN VALUE
+    Success = new tuple with correct attributes
+    Failed = NULL
+*/
+READ_RECORD *Query_tree::do_join(query_node *qn)
+{
+  READ_RECORD *next_tup=0;
+  int i;
+  TABLE *ltable = NULL;
+  TABLE *rtable = NULL;
+  Field *fright = NULL;
+  Field *fleft = NULL;
+  record_buff *lprev=0;
+  record_buff *rprev=0;
+  expr_node *expr;
+
+  DBUG_ENTER("do_join");
+  if (qn == NULL)
+    DBUG_RETURN(NULL);
+
+  /* check join type because some joins require other processing */
+  switch (qn->join_type)
+  {
+    case (jnUNKNOWN) :
+      break;
+    case (jnINNER) :  
+    case (jnLEFTOUTER) :  
+    case (jnRIGHTOUTER) :
+    case (jnFULLOUTER) :
+    {
+
+      /*
+        preempt_pipeline == true means we need to stop the pipeline
+        and sort the incoming rows. We do that by making an in-memory
+        copy of the record buffers stored in left_record_buff and
+        right_record_buff
+      */
+      if (qn->preempt_pipeline)
+      {
+        left_record_buff = NULL;
+        right_record_buff = NULL;
+        next_tup = NULL;
+
+        /* Build buffer for tuples from left child. */
+        do
+        {
+          /* if left child exists, get row from it */
+          if (qn->left != NULL)
+            lbuff = get_next(qn->left);
+
+          /* else, read the row from the table (the storage handler */
+          else
+          {
+            /* 
+               Create space for the record buffer and 
+               store pointer in lbuff
+            */
+            lbuff = (READ_RECORD *) my_malloc(sizeof(READ_RECORD),
+                                      MYF(MY_ZEROFILL | MY_WME));
+            lbuff->rec_buf = 
+              (uchar *) my_malloc(qn->relations[0]->table->s->rec_buff_length,
+                                      MYF(MY_ZEROFILL | MY_WME));
+
+            /* check for end of file. Store result in eof array */
+            qn->eof[0] = 
+              qn->relations[0]->table->file->ha_rnd_next(lbuff->rec_buf);
+            if (qn->eof[0] != HA_ERR_END_OF_FILE)
+              qn->eof[0] = false;
+            else
+            {
+              lbuff = NULL;
+              qn->eof[0] = true;
+            }
+          }
+          /* if the left buffer is not null, get a new row from table */
+          if (lbuff != NULL)
+          {
+            /* we need the table information for processing fields */
+            if (qn->left == NULL)
+              ltable = qn->relations[0]->table;
+            else
+              ltable = get_table(qn->left);
+            if (ltable != NULL)
+              memcpy((uchar *)ltable->record[0], (uchar *)lbuff->rec_buf, 
+                ltable->s->rec_buff_length);
+
+            /* get the join expression */
+            expr = qn->join_expr->get_expression(0);
+            for (Field **field = ltable->field; *field; field++)
+              if (strcasecmp((*field)->field_name, ((Field *)expr->left_op)->field_name)==0)
+                fleft = (*field);
+      
+            /* 
+               If field was found, add the row to the in-memory buffer
+               ordered by the join column.
+            */
+            if ((fleft != NULL) && (!fleft->is_null()))
+              insertion_sort(true, fleft, lbuff);
+          }
+        } while (lbuff != NULL);
+        /* Build buffer for tuples from right child. */
+        do
+        {
+          /* if right child exists, get row from it */
+          if (qn->right != NULL)
+            rbuff = get_next(qn->right);
+
+          /* else, read the row from the table (the storage handler) */
+          else
+          {
+            /* 
+               Create space for the record buffer and 
+               store pointer in rbuff
+            */
+            rbuff = (READ_RECORD *) my_malloc(sizeof(READ_RECORD),
+                                      MYF(MY_ZEROFILL | MY_WME));
+            rbuff->rec_buf = 
+              (uchar *) my_malloc(qn->relations[0]->table->s->rec_buff_length,
+                                      MYF(MY_ZEROFILL | MY_WME));
+
+            /* check for end of file. Store result in eof array */
+            qn->eof[1] = 
+              qn->relations[1]->table->file->ha_rnd_next(rbuff->rec_buf);
+            if (qn->eof[1] != HA_ERR_END_OF_FILE)
+              qn->eof[1] = false;
+            else
+            {
+              rbuff = NULL;
+              qn->eof[1] = true;
+            }
+          }
+          /* if the right buffer is not null, get a new row from table */
+          if (rbuff != NULL)
+          {
+            /* we need the table information for processing fields */
+            if (qn->right == NULL)
+              rtable = qn->relations[1]->table;
+            else
+              rtable = get_table(qn->right);
+            if (rtable != NULL)
+              memcpy((uchar *)rtable->record[0], (uchar *)rbuff->rec_buf, 
+                rtable->s->rec_buff_length);
+
+            /* get the join expression */
+            expr = qn->join_expr->get_expression(0);
+            for (Field **field = rtable->field; *field; field++)
+              if (strcasecmp((*field)->field_name, ((Field *)expr->right_op)->field_name)==0)
+                fright = (*field);
+      
+            /* 
+               If field was found, add the row to the in-memory buffer
+               ordered by the join column.
+            */
+            if ((fright != NULL) && (!fright->is_null()))
+              insertion_sort(false, fright, rbuff);
+          }
+        } while (rbuff != NULL);
+        left_record_buffer_ptr = left_record_buff;
+        right_record_buffer_ptr = right_record_buff;
+        qn->preempt_pipeline = false;
+      }
+      /* 
+        This is where the actual join code begins.
+        We get a tuple from each table and start the compare.
+      */
+
+      /* 
+         if lbuff is null and the left record buffer has data
+         get the row from the buffer
+      */
+      if ((lbuff == NULL) && (left_record_buffer_ptr != NULL))
+      {
+        lbuff = left_record_buffer_ptr->record;
+        lprev = left_record_buffer_ptr;
+        left_record_buffer_ptr = left_record_buffer_ptr->next;
+      }
+
+      /* 
+         if rbuff is null and the right record buffer has data
+         get the row from the buffer
+      */
+      if ((rbuff == NULL) && (right_record_buffer_ptr != NULL))
+      {
+        rbuff = right_record_buffer_ptr->record;
+        rprev = right_record_buffer_ptr;
+        right_record_buffer_ptr = right_record_buffer_ptr->next;
+      }
+
+      /* 
+        if the left buffer was null, check to see if a row is
+        available from left child.
+      */
+      if (ltable == NULL)
+      {
+        if (qn->left == NULL)
+          ltable = qn->relations[0]->table;
+        else
+          ltable = get_table(qn->left);
+      }
+      /* 
+        if the right buffer was null, check to see if a row is
+        available from right child.
+      */
+      if (rtable == NULL)
+      {
+        if (qn->right == NULL)
+          rtable = qn->relations[1]->table;
+        else
+          rtable = get_table(qn->right);
+      }
+      /*
+        If there are two rows to compare, copy the record buffers
+        to the table record buffers. This transfers the data
+        from the internal buffer to the record buffer. It enables
+        us to reuse the MySQL code for manipulating fields.
+      */
+      if ((lbuff != NULL) && (rbuff != NULL))
+      {
+        memcpy((uchar *)ltable->record[0], (uchar *)lbuff->rec_buf, 
+          ltable->s->rec_buff_length);
+        memcpy((uchar *)rtable->record[0], (uchar *)rbuff->rec_buf, 
+          rtable->s->rec_buff_length);
+
+        /* evaluate the join condition */
+        i = qn->join_expr->compare_join(qn->join_expr->get_expression(0), 
+          ltable, rtable);
+
+        /* if there is a match...*/
+        if (i == 0)
+        {
+          /* return the row in the next_tup pointer */
+          next_tup = lbuff;
+ 
+          /* store next rows from buffer (already advanced 1 row) */
+          record_buff *left = left_record_buffer_ptr;
+          record_buff *right = right_record_buffer_ptr;
+
+          /* 
+             Check to see if either buffer needs to be rewound to
+             allow us to process many rows on one side to one row
+             on the other
+          */
+          check_rewind(left_record_buffer_ptr, lprev,
+            right_record_buffer_ptr, rprev);
+
+          /* set poointer to null to force read on next loop */
+          lbuff = NULL;
+          rbuff = NULL;
+
+          /*
+            If the left buffer has been changed and if the 
+            buffer is not at the end, set the buffer to the next row.
+          */
+          if (left != left_record_buffer_ptr)
+          {
+            if (left_record_buffer_ptr != NULL)
+            {
+              lbuff = left_record_buffer_ptr->record;
+            }
+          }
+
+          /*
+            If the right buffer has been changed and if the 
+            buffer is not at the end, set the buffer to the next row.
+          */
+          if (right != right_record_buffer_ptr)
+          {
+            if (right_record_buffer_ptr != NULL)
+            {
+              rbuff = right_record_buffer_ptr->record;
+            }
+          }
+
+          /* Now check for end of file and save results in eof array */
+          if (left_record_buffer_ptr == NULL)
+            qn->eof[2] = true;
+          else
+            qn->eof[2] = false;
+          if (right_record_buffer_ptr == NULL)
+            qn->eof[3] = true;
+          else
+            qn->eof[3] = false;
+        }
+
+        /* if the rows didn't match...*/
+        else
+        {
+          /* get next rows from buffers (already advanced) */
+          record_buff *left = left_record_buffer_ptr;
+          record_buff *right = right_record_buffer_ptr;
+
+          /* 
+             Check to see if either buffer needs to be rewound to
+             allow us to process many rows on one side to one row
+             on the other. The results of this rewind must be
+             saved because there was no match and we may have to
+             reuse one or more of the rows.
+          */
+          check_rewind(left_record_buffer_ptr, lprev,
+            right_record_buffer_ptr, rprev);
+
+          /*
+            If the left buffer has been changed and if the 
+            buffer is not at the end, set the buffer to the next row
+            and copy the data into the record buffer/
+          */
+          if (left != left_record_buffer_ptr)
+          {
+            if (left_record_buffer_ptr != NULL)
+            {
+              memcpy((uchar *)ltable->record[0], 
+                (uchar *)left_record_buffer_ptr->record->rec_buf, 
+                ltable->s->rec_buff_length);
+              lbuff = left_record_buffer_ptr->record;
+            }
+          }
+
+          /*
+            If the right buffer has been changed and if the 
+            buffer is not at the end, set the buffer to the next row
+            and copy the data into the record buffer/
+          */
+          if (right_record_buffer_ptr != NULL)
+            if ((right_record_buffer_ptr->next == NULL) &&
+               (right_record_buffer_ptr->prev == NULL))
+               lbuff = NULL;
+          if (right != right_record_buffer_ptr)
+          {
+            if (right_record_buffer_ptr != NULL)
+            {
+              memcpy((uchar *)rtable->record[0], 
+                (uchar *)right_record_buffer_ptr->record->rec_buf, 
+                rtable->s->rec_buff_length);
+              rbuff = right_record_buffer_ptr->record;
+            }
+          }
+
+          /* Now check for end of file and save results in eof array */
+          if (left_record_buffer_ptr == NULL)
+            qn->eof[2] = true;
+          else
+            qn->eof[2] = false;
+          if (right_record_buffer_ptr == NULL)
+            qn->eof[3] = true;
+          else
+            qn->eof[3] = false;
+            
+          next_tup = NULL;
+        }
+      }
+      else
+      {
+        next_tup = NULL; /* at end, return null */
+      }
+      break;
+    }
+
+    /* placeholder for exercise... */
+    case (jnCROSSPRODUCT) :
+    {
+      break;
+    }
+    /*
+      placeholder for exercises... 
+      Union and intersect are mirrors of each other -- same code will
+      work for both except the dupe elimination/inclusion part (see below)
+    */
+    case (jnUNION) :
+    case (jnINTERSECT) :
+    {
+      break;
+    }
+  }
+  DBUG_RETURN(next_tup);
+}
+
+/*
+  Locates an index if a key field exists in the expression.
+
+  SYNOPSIS
+    find_index_in_expr()
+    query_node *qn IN the operational node in the query tree.
+
+  DESCRIPTION
+    This method is used to locate a key in the expressions. If found,
+    the number of the index is returned.
+
+  NOTES
+    Walks the tree and start all of the iterators.
+    Call this first for each query run.
+
+  RETURN VALUE
+    Success = int index number
+    Failed = -1
+*/
+int Query_tree::find_index_in_expr(Expression *e, char *tbl)
+{
+  int ndx = -1;
+
+  DBUG_ENTER("find_index_in_expr");
+  DBUG_RETURN(ndx);
+}
+
+/*
+  Locates the table from the subtree.
+
+  SYNOPSIS
+    get_table()
+    query_node *qn IN the operational node in the query tree.
+
+  DESCRIPTION
+    This method is used to locate a table from the subtree.
+
+  RETURN VALUE
+    Success = int index number
+    Failed = -1
+*/
+TABLE *Query_tree::get_table(query_node *qn)
+{
+  TABLE *t = NULL;
+  DBUG_ENTER("get_table");
+  if (qn != NULL)
+  {
+    if (qn->left == NULL)
+      t = qn->relations[0]->table;
+    else
+      DBUG_RETURN(get_table(qn->left));
+    if (t == NULL)
+    {
+      if (qn->right == NULL)
+        t = qn->relations[1]->table;
+      else
+        DBUG_RETURN(get_table(qn->right));
+    }
+  }
+  DBUG_RETURN(t);
+}
+
+/*
+  Sort the relation buffer on the following attributes...
+
+  SYNOPSIS
+    insertion_sort()
+    record_buff *buff IN OUT the record buffer you want to insert into.
+    Field *field IN the field for the sort.
+    READ_RECORD *rcd IN the record buffer to insert.
+
+  DESCRIPTION
+    This method is used to create a buffer of ordered record buffers.
+
+  NOTES
+    To initialize a new buffer, pass NULL for field value then call
+    again for each record inserted.
+
+  RETURN VALUE
+    Success = int index number
+    Failed = -1
+*/
+int Query_tree::insertion_sort(bool left, 
+                               Field *field, 
+                               READ_RECORD *rcd)
+{
+  int i;
+  record_buff *b_ptr;
+  record_buff *n_ptr;
+  record_buff *p_ptr;
+  record_buff *buff;
+  bool found = false;
+  char buffer[MAX_FIELD_WIDTH];
+  String str(buffer,sizeof(buffer),&my_charset_bin);
+
+  DBUG_ENTER("sort");
+  if ((field == NULL) || (rcd == NULL))
+    DBUG_RETURN(-1);
+
+  /* Check for None field - ignore these! */
+  field->val_str(&str);
+  if (strncasecmp(str.ptr(), "NONE", 4)==0)
+    DBUG_RETURN(-1);
+
+  if (left)
+    buff = left_record_buff;
+  else
+    buff = right_record_buff;
+  if (buff == NULL)
+  {
+    buff = (record_buff *)my_malloc(sizeof(record_buff), MYF(MY_ZEROFILL |MY_WME));
+    field->val_str(&str);
+    buff->field_ptr = (uchar *)my_malloc(str.length(), 
+      MYF(MY_ZEROFILL |MY_WME));
+    memcpy(buff->field_ptr, str.ptr(), str.length());
+    buff->field_length = str.length();
+    buff->record = rcd;
+    buff->next = NULL;
+    buff->prev = NULL;
+    if (left)
+      left_record_buff = buff;
+    else
+      right_record_buff = buff;
+  }
+  else 
+  {
+    b_ptr = buff;
+    while (!found && (b_ptr != NULL))
+    {
+      field->val_str(&str);
+      i = memcmp(str.ptr(), b_ptr->field_ptr, 
+        (long)str.length() < b_ptr->field_length ? 
+        strlen(field->field_name) : b_ptr->field_length);
+      if (i < 0)
+      {
+        if (buff == b_ptr)
+        {
+          n_ptr = (record_buff *)my_malloc(sizeof(record_buff), 
+            MYF(MY_WME));
+          n_ptr->field_ptr = (uchar *)my_malloc(str.length(), 
+            MYF(MY_WME));
+          memcpy(n_ptr->field_ptr, str.ptr(), str.length());
+          n_ptr->field_length = str.length();
+          n_ptr->record = rcd;
+          n_ptr->prev = NULL;
+          buff->prev = n_ptr;
+          n_ptr->next = buff;
+          buff = n_ptr;
+          if (left)
+            left_record_buff = n_ptr;
+          else
+            right_record_buff = n_ptr;
+          found = true;
+        }
+        else
+        {
+          p_ptr = b_ptr->prev;
+          p_ptr->next = (record_buff *)my_malloc(sizeof(record_buff), 
+            MYF(MY_WME));
+          p_ptr->next->next = b_ptr;
+          b_ptr->prev = p_ptr->next;
+          p_ptr->next->field_ptr = 
+            (uchar *)my_malloc(str.length(), MYF(MY_WME));
+          memcpy(p_ptr->next->field_ptr, str.ptr(), str.length());
+          p_ptr->next->field_length = str.length();
+          p_ptr->next->prev = p_ptr;
+          p_ptr->next->record = rcd;
+          found = true;
+        }
+      }
+      else if (b_ptr->next == NULL)
+      {
+        b_ptr->next = (record_buff *)my_malloc(sizeof(record_buff), 
+          MYF(MY_WME));
+        b_ptr->next->next = NULL;
+        b_ptr->next->field_ptr = 
+          (uchar *)my_malloc(str.length(), MYF(MY_WME));
+        memcpy(b_ptr->next->field_ptr, str.ptr(), str.length());
+        b_ptr->next->field_length = str.length();
+        b_ptr->next->prev = b_ptr;
+        b_ptr->next->record = rcd;
+        found = true;
+      }
+      else
+        b_ptr = b_ptr->next;
+    }
+  }
+  DBUG_RETURN(0);
+}
+
+/*
+  Adjusts pointers to record buffers for join.
+
+  SYNOPSIS
+    check_rewind()
+    record_buff *cur_left IN the left record buffer
+    record_buff *cur_left_prev IN the left record buffer previous
+    record_buff *cur_right IN the left record buffer
+    record_buff *cur_right_prev IN the left record buffer previous
+
+  DESCRIPTION
+    This method is used to push a tuple back into the buffer 
+    during a join operation that preempts the pipeline.
+
+  NOTES
+    Now, here's where we have to check the next tuple in each
+    relation to see if they are the same. If one of them is the
+    same and the other isn't, push one of them back.
+
+    We need to rewind if one of the following is true:
+    1. The next record in R2 has the same join value as R1
+    2. The next record in R1 has the same join value as R2
+    3. The next record in R1 has the same join value and R2 is 
+       different (or EOF)
+    4. The next record in R2 has the same join value and R1 is 
+       different (or EOF)
+
+  RETURN VALUE
+    Success = int index number
+    Failed = -1
+*/
+int Query_tree::check_rewind(record_buff *cur_left, 
+                             record_buff *curr_left_prev,
+                             record_buff *cur_right, 
+                             record_buff *curr_right_prev)
+{
+  record_buff *left_rcd_ptr = cur_left;
+  record_buff *right_rcd_ptr = cur_right;
+  int i;
+  DBUG_ENTER("check_rewind");
+
+  /*
+    If the next tuple in right record is the same as the present tuple
+      AND the next tuple in right record is different, rewind until 
+      it is the same
+    else
+      Push left record back.
+  */
+
+  /* if both buffers are at EOF, return -- nothing to do */
+  if ((left_rcd_ptr == NULL) && (right_rcd_ptr == NULL))
+    DBUG_RETURN(0);
+
+  /* if the currently processed record is null, get the one before it */
+  if (cur_right == NULL)
+    right_rcd_ptr = curr_right_prev;
+
+  /* 
+    if left buffer is not at end, check to see 
+    if we need to rewind right buffer 
+  */
+  if (left_rcd_ptr != NULL)
+  {
+    /* compare the join conditions to check order */
+    i = memcmp(left_rcd_ptr->field_ptr, right_rcd_ptr->field_ptr, 
+      left_rcd_ptr->field_length < right_rcd_ptr->field_length ? 
+      left_rcd_ptr->field_length : right_rcd_ptr->field_length);
+
+    /*
+      i == 0 means the rows are the same. In this case, we need to
+      check to see if we need to advance or rewind the right buffer.
+    */
+    if (i == 0)
+    {
+      /*
+        If there is a next row in the right buffer, check to see
+        if it matches the left row. If the right row is greater
+        than the left row, rewind the right buffer to one previous
+        to the current row or until we hit the start.
+      */
+      if (right_rcd_ptr->next != NULL)
+      {
+        right_rcd_ptr = right_rcd_ptr->next;
+        i = memcmp(left_rcd_ptr->field_ptr, right_rcd_ptr->field_ptr, 
+          left_rcd_ptr->field_length < right_rcd_ptr->field_length ? 
+          left_rcd_ptr->field_length : right_rcd_ptr->field_length);
+        if (i > 0)
+        {
+          do
+          {
+            if (right_rcd_ptr->prev != NULL)
+            {
+              right_rcd_ptr = right_rcd_ptr->prev;
+              i = memcmp(left_rcd_ptr->field_ptr, right_rcd_ptr->field_ptr, 
+                left_rcd_ptr->field_length < right_rcd_ptr->field_length ? 
+                left_rcd_ptr->field_length : right_rcd_ptr->field_length);
+            }
+          }
+          while ((i == 0) && (right_rcd_ptr->prev != NULL));
+
+          /* now advance one more to set pointer to correct location */
+          if (right_rcd_ptr->next != NULL)
+            right_rcd_ptr = right_rcd_ptr->next;
+        }
+        /* if no next right row, rewind to previous row */
+        else
+          right_rcd_ptr = right_rcd_ptr->prev;
+      }
+      /*
+        If there is a next row in the left buffer, check to see
+        if it matches the right row. If there is a match and the right
+        buffer is not at start, rewind the right buffer to one previous
+        to the current row.
+      */
+      else if (left_rcd_ptr->next != NULL)
+      {
+        if (right_rcd_ptr->prev != NULL)
+        {
+          i = memcmp(left_rcd_ptr->field_ptr, right_rcd_ptr->prev->field_ptr, 
+            left_rcd_ptr->field_length < right_rcd_ptr->prev->field_length ? 
+            left_rcd_ptr->field_length : right_rcd_ptr->prev->field_length);
+        }
+        if ((i == 0) && (right_rcd_ptr->prev != NULL))
+          right_rcd_ptr = right_rcd_ptr->prev;
+      }
+    }
+    /* if the left row is less than right row, rewind right buffer */
+    else if (i < 0)
+    {
+      if (right_rcd_ptr->prev != NULL)
+        right_rcd_ptr = right_rcd_ptr->prev;
+    }
+    /* if the right row is less than the left row, advance right row */
+    else
+    {
+      if (right_rcd_ptr->next != NULL)
+        right_rcd_ptr = right_rcd_ptr->next;
+    }
+  }
+  /* 
+    Rows don't match so advance the right buffer and check match again.
+    if they still match, rewind left buffer.
+  */
+  else
+  {
+    if (right_rcd_ptr->next != NULL)
+    {
+      i = memcmp(curr_left_prev->field_ptr, right_rcd_ptr->field_ptr, 
+        curr_left_prev->field_length < right_rcd_ptr->field_length ? 
+        curr_left_prev->field_length : right_rcd_ptr->field_length);
+      if (i == 0)
+        left_rcd_ptr = curr_left_prev;
+    }
+  }
+  /* set buffer pointers to adjusted rows from buffers */
+  left_record_buffer_ptr = left_rcd_ptr;
+  right_record_buffer_ptr = right_rcd_ptr;
+  DBUG_RETURN(0);
+}

=== added file 'sql/query_tree.h'
--- sql/query_tree.h	1970-01-01 00:00:00 +0000
+++ sql/query_tree.h	2012-09-13 22:28:13 +0000
@@ -0,0 +1,174 @@
+/*
+  Query_tree.h
+
+  DESCRIPTION
+    This file contains the Query_tree class. It is responsible for containing the
+    internal representation of the query to be executed. It provides methods for
+    optimizing and forming and inspecting the query tree. This class is the very
+    heart of the DBXP query capability! It also provides the ability to store
+    a binary "compiled" form of the query.
+
+  NOTES
+    The data structure is a binary tree that can have 0, 1, or 2 children. Only
+    Join operations can have 2 children. All other operations have 0 or 1 
+    children. Each node in the tree is an operation and the links to children
+    are the pipeline.
+ 
+  SEE ALSO
+    query_tree.cc
+*/
+#include "attribute.h"
+#include "expression.h"
+#include "sql_priv.h"
+#include "sql_class.h"
+#include "table.h"
+#include "records.h"
+
+const int MAXNODETABLES = 4;
+const int LEFTCHILD = 0;
+const int RIGHTCHILD = 1;
+
+class Query_tree
+{
+public:
+  enum query_node_type          //this enumeration lists the available
+  {                              //query node (operations)
+    qntUndefined = 0,
+    qntRestrict = 1,
+    qntProject = 2,
+    qntJoin = 3,
+    qntSort = 4,
+    qntDistinct = 5
+  };
+
+  enum join_con_type            //this enumeration lists the available
+  {                              //join operations supported
+    jcUN = 0,
+    jcNA = 1,
+    jcON = 2,
+    jcUS = 3
+  };
+
+  enum type_join                //this enumeration lists the available
+  {                              //join types supported.
+    jnUNKNOWN      = 0,          //undefined
+    jnINNER        = 1,
+    jnLEFTOUTER    = 2,
+    jnRIGHTOUTER   = 3,
+    jnFULLOUTER    = 4,
+    jnCROSSPRODUCT = 5,
+    jnUNION        = 6,
+    jnINTERSECT    = 7
+  };
+
+    enum AggregateType          //used to add aggregate functions
+    {
+        atNONE      = 0,
+        atCOUNT     = 1
+    };
+
+  /*
+    STRUCTURE query_node
+
+    DESCRIPTION
+      This this structure contains all of the data for a query node:
+
+      NodeId -- the internal id number for a node
+      ParentNodeId -- the internal id for the parent node (used for insert)
+      SubQuery -- is this the start of a subquery?
+      Child -- is this a Left or Right child of the parent?
+      NodeType -- synonymous with operation type
+      JoinType -- if a join, this is the join operation
+      join_con_type -- if this is a join, this is the "on" condition
+      Expressions -- the expressions from the "where" clause for this node
+      Join Expressions -- the join expressions from the "join" clause(s) 
+      Relations[] -- the relations for this operation (at most 2)
+      PreemptPipeline -- does the pipeline need to be halted for a sort?
+      Fields -- the attributes for the result set of this operation
+      Left -- a pointer to the left child node
+      Right -- a pointer to the right child node
+*/
+  struct query_node            
+  {
+    query_node();
+    ~query_node();
+    int                 nodeid;
+    int                 parent_nodeid;
+    bool                sub_query;
+    int                 child; 
+    query_node_type     node_type;
+    type_join           join_type;
+    join_con_type       join_cond;
+    Expression          *where_expr;
+    Expression          *join_expr;
+    TABLE_LIST          *relations[MAXNODETABLES];
+    int                 eof[MAXNODETABLES];
+    int                 ndx[MAXNODETABLES];
+    bool                preempt_pipeline;
+    Attribute           *attributes;
+    query_node          *left;
+    query_node          *right;
+  };
+
+  struct record_buff
+  {
+    uchar *field_ptr;
+    long field_length;
+    record_buff *next;
+    record_buff *prev;
+    READ_RECORD *record;
+  };
+
+  query_node *root;              //The ROOT node of the tree
+
+  Query_tree(void);
+  ~Query_tree(void);
+  int init_node(query_node *qn);
+  int heuristic_optimization();
+  int cost_optimization();
+  int insert_attribute(query_node *qn, Item *c);
+  bool distinct;
+  int prepare(query_node *qn);
+  int cleanup(query_node *qn);
+  bool Eof(query_node *qn);
+  READ_RECORD *get_next(query_node *qn);
+  List <Item> result_fields;
+
+private:
+  bool h_opt;              //has query been optimized (rules)?
+  bool c_opt;              //has query been optimized (cost)?
+  READ_RECORD *lbuff;
+  READ_RECORD *rbuff;
+  record_buff *left_record_buff;
+  record_buff *right_record_buff;
+  record_buff *left_record_buffer_ptr;
+  record_buff *right_record_buffer_ptr;
+
+  int push_projections(query_node *qn, query_node *pNode);
+  query_node *find_projection(query_node *qn);
+  bool is_leaf(query_node *qn);
+  bool has_relation(query_node *qn, char *Table);
+  bool has_attribute(query_node *qn, Item *a);
+  int del_attribute(query_node *qn, Item *a);
+  int push_restrictions(query_node *qn, query_node *pNode);
+  query_node *find_restriction(query_node *qn);
+  query_node *find_join(query_node *qn);
+  int push_joins(query_node *qn, query_node *pNode);
+  int prune_tree(query_node *prev, query_node *cur_node);
+  int balance_joins(query_node *qn);
+  int split_restrict_with_project(query_node *qn);
+  int split_restrict_with_join(query_node *qn);
+  int split_project_with_join(query_node *qn);
+  bool find_table_in_tree(query_node *qn, char *tbl);
+  bool find_table_in_expr(Expression *expr, char *tbl);
+  bool find_attr_in_expr(Expression *expr, char *tbl, char *value);
+  int apply_indexes(query_node *qn);
+  bool do_restrict(query_node *qn, READ_RECORD *t);
+  READ_RECORD *do_project(query_node *qn, READ_RECORD *t);
+  READ_RECORD *do_join(query_node *qn);
+  int find_index_in_expr(Expression *e, char *tbl);
+  TABLE *get_table(query_node *qn);
+  int insertion_sort(bool left, Field *field, READ_RECORD *rcd);
+  int check_rewind(record_buff *cur_left, record_buff *curr_left_prev,
+    record_buff *cur_right, record_buff *cur_right_prev);
+};

=== modified file 'sql/sql_cmd.h'
--- sql/sql_cmd.h	2012-09-11 17:35:40 +0000
+++ sql/sql_cmd.h	2012-09-13 22:28:13 +0000
@@ -43,6 +43,13 @@ enum enum_sql_command {
   SQLCOM_SHOW_COLLATIONS, SQLCOM_SHOW_CREATE_DB, SQLCOM_SHOW_TABLE_STATUS,
   SQLCOM_SHOW_TRIGGERS,
 
+/* BEGIN DBXP MODIFICATION */ 
+/* Reason for Modification: */
+/* This section captures the enumerations for the DBXP command tokens */
+  SQLCOM_DBXP_SELECT,   
+  SQLCOM_DBXP_EXPLAIN_SELECT,   
+/* END DBXP MODIFICATION */
+
   SQLCOM_LOAD,SQLCOM_SET_OPTION,SQLCOM_LOCK_TABLES,SQLCOM_UNLOCK_TABLES,
   SQLCOM_GRANT,
   SQLCOM_CHANGE_DB, SQLCOM_CREATE_DB, SQLCOM_DROP_DB, SQLCOM_ALTER_DB,

=== added file 'sql/sql_dbxp_parse.cc'
--- sql/sql_dbxp_parse.cc	1970-01-01 00:00:00 +0000
+++ sql/sql_dbxp_parse.cc	2012-09-16 17:27:46 +0000
@@ -0,0 +1,521 @@
+/*
+  sql_dbxp_parse.cc
+
+  DESCRIPTION
+    This file contains methods to execute the DBXP SELECT query statements.
+
+  NOTES
+    The data structure is a binary tree that can have 0, 1, or 2 children. Only
+    Join operations can have 2 children. All other operations have 0 or 1 
+    children. Each node in the tree is an operation and the links to children
+    are the pipeline.
+ 
+  SEE ALSO
+    query_tree.cc
+*/
+#include "query_tree.h"
+#include "sql_base.h"
+#include "sql_acl.h"
+#include "sql_parse.h"
+#include "lock.h"
+
+/*
+  Build Query Tree
+
+  SYNOPSIS
+    build_query_tree()
+    THD *thd            IN the current thread
+    LEX *lex            IN the pointer to the current parsed structure
+    TABLE_LIST *tables  IN the list of tables identified in the query
+
+  DESCRIPTION
+    This method returns a converted MySQL internal representation (IR) of a
+    query as a query_tree.
+
+  RETURN VALUE
+    Success = Query_tree * -- the root of the new query tree.
+    Failed = NULL
+*/
+Query_tree *build_query_tree(THD *thd, LEX *lex, TABLE_LIST *tables)
+{
+  DBUG_ENTER("build_query_tree");
+  Query_tree *qt = new Query_tree();
+  Query_tree::query_node *qn = 
+    (Query_tree::query_node *)my_malloc(sizeof(Query_tree::query_node), 
+    MYF(MY_ZEROFILL | MY_WME));
+  TABLE_LIST *table;
+  int i = 0;
+  Item *w;
+  int num_tables = 0;
+
+  /* create a new restrict node */
+  qn->parent_nodeid = -1;
+  qn->child = false;
+  qn->join_type = (Query_tree::type_join) 0;
+  qn->nodeid = 0;
+  qn->node_type = (Query_tree::query_node_type) 2; 
+  qn->left = NULL;
+  qn->right = NULL;
+  qn->attributes = new Attribute();
+  qn->where_expr = new Expression();
+  qn->join_expr = new Expression();
+
+  if(lex->select_lex.options & SELECT_DISTINCT)
+  {
+    //qt->set_distinct(true); /* placeholder for exercise */
+  }
+
+  /* Get the tables (relations) */
+  i = 0;
+  for(table = tables; table; table = table->next_local)
+  {
+    num_tables++;
+    qn->relations[i] = table;
+    i++;
+  }
+
+  /* prepare the fields (find associated tables) for query */
+  List <Item> all_fields;
+  Name_resolution_context context;
+  List_iterator <Item> it(thd->lex->select_lex.item_list);
+  it++;
+  if (lex->select_lex.with_wild)
+  {
+    bool found = FALSE;
+    Field_iterator_table_ref field_iterator;
+    for(table = tables; table; table = table->next_local)
+    {
+      field_iterator.set(table);
+      for (; !field_iterator.end_of_fields(); field_iterator.next())
+      {
+        Item *item= field_iterator.create_item(thd);
+        if (!found)
+        {
+          found= TRUE;
+          it.replace(item); /* Replace '*' with the first found item. */
+        }
+        else
+        {
+          it.after(item);   /* Add 'item' to the SELECT list. */
+        }
+      }
+    }
+  }
+//  if (setup_wild(thd, tables, thd->lex->select_lex.item_list, &all_fields,
+//                 thd->lex->select_lex.with_wild))
+//    DBUG_RETURN(NULL);  
+  if (setup_fields(thd, lex->select_lex.ref_pointer_array,
+                   lex->select_lex.item_list, thd->mark_used_columns,
+                   &all_fields, 1))
+    DBUG_RETURN(NULL);  
+  qt->result_fields = lex->select_lex.item_list;
+  
+  /* get the attributes from the raw query */
+  w = lex->select_lex.item_list.pop();
+  while (w != 0)
+  {
+    uint unused_field_idx= NO_CACHED_FIELD_INDEX;
+    TABLE_LIST *dummy;
+    Field *f = NULL;
+    for(table = tables; table; table = table->next_local)
+    {
+      f = find_field_in_table_ref(thd, table, ((Field *)w)->field_name,
+                                  strlen(((Field *)w)->field_name),
+                                  ((Field *)w)->field_name, NULL, NULL, NULL,
+                                  FALSE, FALSE, &unused_field_idx, FALSE,
+                                  &dummy);
+      if (f)
+      {
+        qn->attributes->add_attribute(true, (Item *)f);
+        break;
+      }
+    }
+    w = lex->select_lex.item_list.pop();
+  }
+
+  /* get the joins from the raw query */
+  if (num_tables > 0)  //indicates more than 1 table processed
+    for(table = tables; table; table = table->next_local)
+    {
+      if (table->join_cond() != 0)
+        qn->join_expr->convert(thd, (Item *)table->join_cond());
+//      if (table->cond_equal != 0)
+//        qn->join_expr->convert(thd, (Item *)table->cond_equal);
+    }
+
+  /* get the expressions for the where clause */
+  qn->where_expr->convert(thd, lex->select_lex.where);
+
+  /* get the join conditions for the joins */
+  qn->join_expr->get_join_expr(qn->where_expr);
+
+  /* if there is a where clause, set node to restrict */
+  if (qn->where_expr->num_expressions() > 0)
+    qn->node_type = (Query_tree::query_node_type) 1;
+
+  qt->root = qn;
+  DBUG_RETURN(qt);
+}
+
+int DBXP_explain_select_command(THD *thd);
+
+/*
+  Send data
+
+  SYNOPSIS
+    send_data()
+    Protocol *p        IN the Protocol class 
+    THD *thd           IN the current thread
+    List<Item> *items  IN the list of fields identified in the row
+
+  DESCRIPTION
+    This method sends the data to the clien using the protocol class.
+
+  RETURN VALUE
+    Success = 0
+    Failed = 1
+*/
+bool send_data(Protocol *protocol, List<Item> &items, THD *thd)
+{
+
+  /* use a list iterator to loop through items */
+  List_iterator_fast<Item> li(items);
+
+  char buff[MAX_FIELD_WIDTH];
+  String buffer(buff, sizeof(buff), &my_charset_bin);
+  DBUG_ENTER("send_data");
+
+  /* this call resets the transmission buffers */
+  protocol->prepare_for_resend();
+
+  /* for each item in the list (a field), send data to the client */
+  Item *item;
+  while ((item=li++))
+  {
+    /* 
+      Use the MySQL send method for the item class to write to network.
+      If unsuccessful, free memory and send error message to client.
+    */
+    if (item->send(protocol, &buffer))
+    {
+      protocol->free();        /* Free used buffer */
+      my_message(ER_OUT_OF_RESOURCES, ER(ER_OUT_OF_RESOURCES), MYF(0));
+      break;
+    }
+  }
+  /* increment row count */
+  thd->inc_sent_row_count(1);
+ 
+  /* if network write was ok, return */
+  if (thd->vio_ok())
+    DBUG_RETURN(protocol->write());
+
+  DBUG_RETURN(0);
+}
+
+/*
+  Perform Select Command
+
+  SYNOPSIS
+    DBXP_select_command()
+    THD *thd            IN the current thread
+
+  DESCRIPTION
+    This method executes the SELECT command using the query tree and optimizer.
+
+  RETURN VALUE
+    Success = 0
+    Failed = 1
+*/
+int DBXP_select_command(THD *thd)
+{
+  bool res;
+  READ_RECORD *record;
+  select_result *result = thd->lex->result;
+
+  DBUG_ENTER("DBXP_select_command");
+
+  /* Prepare the tables (check access, locks) */
+  res = check_table_access(thd, SELECT_ACL, thd->lex->query_tables, 0, 1, 1);
+  if (res)
+    DBUG_RETURN(1);
+  res = open_and_lock_tables(thd, thd->lex->query_tables, 0,
+                             MYSQL_LOCK_IGNORE_TIMEOUT);
+  if (res)
+    DBUG_RETURN(1);
+
+  /* Create the query tree and optimize it */
+  Query_tree *qt = build_query_tree(thd, thd->lex, 
+                     (TABLE_LIST*) thd->lex->select_lex.table_list.first);
+  qt->heuristic_optimization();
+  qt->cost_optimization();
+  qt->prepare(qt->root);
+  if (!(result= new select_send()))
+    DBUG_RETURN(1);
+
+  /* use the protocol class to communicate to client */
+  Protocol *protocol= thd->protocol;
+
+  /* write the field list for returning the query results */
+  if (protocol->send_result_set_metadata(&qt->result_fields, 
+                            Protocol::SEND_NUM_ROWS | Protocol::SEND_EOF))
+    DBUG_RETURN(1);
+
+  /* pulse the execution engine to get a row from the result set */
+  while (!qt->Eof(qt->root))
+  {
+    record = qt->get_next(qt->root);
+    if (record != NULL)
+    {
+      /* send the data to the client */
+      send_data(protocol, qt->result_fields, thd);
+    }
+  }
+  my_eof(thd);
+
+  /* unlock tables and cleanup memory */
+  qt->cleanup(qt->root);
+  mysql_unlock_read_tables(thd, thd->lock);
+  delete qt;
+  DBUG_RETURN(0);
+}
+
+/*
+  Write to vio with printf.
+
+  SYNOPSIS
+    write_printf()
+    Protocol *p     IN the Protocol class 
+    char *first     IN the first string to write
+    char *last      IN the last string to write
+
+  DESCRIPTION
+    This method writes to the vio routines printing the strings passed.
+
+  RETURN VALUE
+    Success = 0
+    Failed = 1
+*/
+int write_printf(Protocol *p, char *first, const char *last)
+{
+  char *str = (char *)my_malloc(256, MYF(MY_ZEROFILL | MY_WME));
+
+  DBUG_ENTER("write_printf");
+  strcpy(str, first);
+  strcat(str, last);
+  p->prepare_for_resend();
+  p->store(str, system_charset_info);
+  p->write();
+  my_free(str);
+  DBUG_RETURN(0);
+}
+
+/*
+  Show Query Plan
+
+  SYNOPSIS
+    show_plan()
+    Protocol *p         IN the MySQL protocol class
+    query_node *Root    IN the root node of the query tree
+    query_node *qn      IN the starting node to be operated on.
+    bool print_on_right IN indicates the printing should tab to the right 
+                           of the display.
+
+  DESCRIPTION
+    This method prints the execute plan to the client via the protocol class
+
+  WARNING
+    This is a RECURSIVE method!
+    Uses postorder traversal to draw the quey plan
+
+  RETURN VALUE
+    Success = 0
+    Failed = 1
+*/
+int show_plan(Protocol *p, Query_tree::query_node *root, 
+              Query_tree::query_node *qn, bool print_on_right)
+{
+  DBUG_ENTER("show_plan");
+
+  /* spacer is used to fill white space in the output */
+  char *spacer = (char *)my_malloc(80, MYF(MY_ZEROFILL | MY_WME));
+  char *tblname = (char *)my_malloc(256, MYF(MY_ZEROFILL | MY_WME));
+
+  if(qn != 0)
+  {
+    show_plan(p, root, qn->left, print_on_right);
+    show_plan(p, root, qn->right, true);
+    
+    /* draw incoming arrows */
+    if(print_on_right)
+      strcpy(spacer, "          |               ");
+    else
+      strcpy(spacer, "     ");
+
+    /* Write out the name of the database and table */
+    if((qn->left == NULL) && (qn->right == NULL))
+    {
+      /*
+         If this is a join, it has 2 children so we need to write
+         the children nodes feeding the join node. Spaces are used
+         to place the tables side-by-side.
+      */
+      if(qn->node_type == Query_tree::qntJoin)
+      {
+        strcpy(tblname, spacer);
+        strcat(tblname, qn->relations[0]->db);
+        strcat(tblname, ".");
+        strcat(tblname, qn->relations[0]->table_name);
+        if(strlen(tblname) < 15)
+          strcat(tblname, "               ");
+        else
+          strcat(tblname, "          ");
+        strcat(tblname, qn->relations[1]->db);
+        strcat(tblname, ".");
+        strcat(tblname, qn->relations[1]->table_name);
+        write_printf(p, tblname, "");
+        write_printf(p, spacer, "     |                              |");
+        write_printf(p, spacer, "     |   ----------------------------");
+        write_printf(p, spacer, "     |   |");
+        write_printf(p, spacer, "     V   V");
+      }
+      else
+      {
+        strcpy(tblname, spacer);
+        strcat(tblname, qn->relations[0]->db);
+        strcat(tblname, ".");
+        strcat(tblname, qn->relations[0]->table_name);
+        write_printf(p, tblname, "");
+        write_printf(p, spacer, "     |");
+        write_printf(p, spacer, "     |");
+        write_printf(p, spacer, "     |");
+        write_printf(p, spacer, "     V");
+      }
+    }
+    else if((qn->left != 0) && (qn->right != 0))
+    {
+      write_printf(p, spacer, "     |                              |");
+      write_printf(p, spacer, "     |   ----------------------------");
+      write_printf(p, spacer, "     |   |");
+      write_printf(p, spacer, "     V   V");
+    }
+    else if((qn->left != 0) && (qn->right == 0))
+    {
+      write_printf(p, spacer, "     |");
+      write_printf(p, spacer, "     |");
+      write_printf(p, spacer, "     |");
+      write_printf(p, spacer, "     V");
+    }
+    else if(qn->right != 0)
+    {
+    }
+    write_printf(p, spacer, "-------------------");
+
+    /* Write out the node type */
+    switch(qn->node_type)
+    {
+    case Query_tree::qntProject:
+      {
+        write_printf(p, spacer, "|     PROJECT     |");
+        write_printf(p, spacer, "-------------------");
+        break;
+      }
+    case Query_tree::qntRestrict:
+      {
+        write_printf(p, spacer, "|    RESTRICT     |");
+        write_printf(p, spacer, "-------------------");
+        break;
+      }
+    case Query_tree::qntJoin:
+      {
+        write_printf(p, spacer, "|      JOIN       |");
+        write_printf(p, spacer, "-------------------");
+        break;
+      }
+    case Query_tree::qntDistinct:
+      {
+        write_printf(p, spacer, "|     DISTINCT    |");
+        write_printf(p, spacer, "-------------------");
+        break;
+      }
+    default:
+      {
+        write_printf(p, spacer, "|      UNDEF      |");
+        write_printf(p, spacer, "-------------------");
+        break;
+      }
+    }
+    write_printf(p, spacer, "| Access Method:  |");
+    write_printf(p, spacer, "|    iterator     |");
+    write_printf(p, spacer, "-------------------");
+    if(qn == root)
+    {
+      write_printf(p, spacer, "        |");
+      write_printf(p, spacer, "        |");
+      write_printf(p, spacer, "        V");
+      write_printf(p, spacer, "    Result Set");
+    }
+  }
+  my_free(spacer);
+  my_free(tblname);
+  DBUG_RETURN(0);
+}
+
+
+/*
+  Perform EXPLAIN command.
+
+  SYNOPSIS
+    DBXP_explain_select_command()
+    THD *thd            IN the current thread
+
+  DESCRIPTION
+    This method executes the EXPLAIN SELECT command.
+
+  RETURN VALUE
+    Success = 0
+    Failed = 1
+*/
+int DBXP_explain_select_command(THD *thd)
+{
+  bool res;
+
+  DBUG_ENTER("DBXP_explain_select_command");
+
+  /* Prepare the tables (check access, locks) */
+  res = check_table_access(thd, SELECT_ACL, thd->lex->query_tables, 0, 1, 1);
+  if (res)
+    DBUG_RETURN(1);
+  res = open_and_lock_tables(thd, thd->lex->query_tables, 0,
+                             MYSQL_LOCK_IGNORE_TIMEOUT);
+  if (res)
+    DBUG_RETURN(1);
+
+  /* Create the query tree and optimize it */
+  Query_tree *qt = build_query_tree(thd, thd->lex, 
+           (TABLE_LIST*) thd->lex->select_lex.table_list.first);
+  qt->heuristic_optimization();
+  qt->cost_optimization();
+
+  /* create a field list for returning the query plan */
+  List<Item> field_list;
+
+  /* use the protocol class to communicate to client */
+  Protocol *protocol= thd->protocol;
+
+  /* write the field to the client */
+  field_list.push_back(new Item_empty_string("Execution Path",NAME_LEN));
+  if (protocol->send_result_set_metadata(&field_list,
+                            Protocol::SEND_NUM_ROWS | Protocol::SEND_EOF))
+    DBUG_RETURN(TRUE);
+  protocol->prepare_for_resend();
+  
+  /* generate the query plan and send it to client */
+  show_plan(protocol, qt->root, qt->root, false);
+  my_eof(thd); /* end of file tells client no more data is coming */
+
+  /* unlock tables and cleanup memory */
+  mysql_unlock_read_tables(thd, thd->lock);
+  delete qt;
+  DBUG_RETURN(0);
+}

=== modified file 'sql/sql_parse.cc'
--- sql/sql_parse.cc	2012-09-11 17:35:40 +0000
+++ sql/sql_parse.cc	2012-09-13 22:28:13 +0000
@@ -2197,6 +2197,13 @@ err:
 }
 
 
+/* BEGIN DBXP MODIFICATION */
+/* Reason for Modification: */
+/* This section adds the code to call the new SELECT DBXP command. */
+int DBXP_select_command(THD *thd);
+int DBXP_explain_select_command(THD *thd);
+/* END DBXP MODIFICATION */
+
 /**
   Execute command saved in thd and lex->sql_command.
 
@@ -2552,6 +2559,20 @@ mysql_execute_command(THD *thd)
     res= execute_sqlcom_select(thd, all_tables);
     break;
   }
+/* BEGIN DBXP MODIFICATION */
+/* Reason for Modification: */
+/* This section adds the code to call the new SELECT DBXP command. */
+  case SQLCOM_DBXP_SELECT:
+  {
+    DBXP_select_command(thd);
+    break;
+  }
+  case SQLCOM_DBXP_EXPLAIN_SELECT:
+  {
+    DBXP_explain_select_command(thd);
+    break;
+  }
+/* END DBXP MODIFICATION */
 case SQLCOM_PREPARE:
   {
     mysql_sql_stmt_prepare(thd);

=== modified file 'sql/sql_yacc.yy'
--- sql/sql_yacc.yy	2012-09-11 17:35:40 +0000
+++ sql/sql_yacc.yy	2012-09-16 00:03:37 +0000
@@ -1124,6 +1124,11 @@ bool my_yyoverflow(short **a, YYSTYPE **
 %token  DAY_MINUTE_SYM
 %token  DAY_SECOND_SYM
 %token  DAY_SYM                       /* SQL-2003-R */
+/* BEGIN DBXP MODIFICATION */
+/* Reason for Modification: */
+/* This section defines the tokens for the DBXP commands */
+%token  DBXP_SELECT_SYM  
+/* END DBXP MODIFICATION */
 %token  DEALLOCATE_SYM                /* SQL-2003-R */
 %token  DECIMAL_NUM
 %token  DECIMAL_SYM                   /* SQL-2003-R */
@@ -1801,7 +1806,11 @@ bool my_yyoverflow(short **a, YYSTYPE **
 %type <boolfunc2creator> comp_op
 
 %type <NONE>
-        query verb_clause create change select do drop insert replace insert2
+/* BEGIN DBXP MODIFICATION */
+/* Reason for Modification: */
+/* Add the dbxp_select statement to the NONE type definition. */
+        query verb_clause create change select dbxp_select do drop insert replace insert2
+/* END DBXP MODIFICATION */
         insert_values update delete truncate rename
         show describe load alter optimize keycache preload flush
         reset purge begin commit rollback savepoint release
@@ -2019,6 +2028,11 @@ statement:
         | rollback
         | savepoint
         | select
+/* BEGIN DBXP MODIFICATION */
+/* Reason for Modification: */
+/* Add the dbxp_select statement to the list of statements(commands). */
+        | dbxp_select
+/* END DBXP MODIFICATION */
         | set
         | signal_stmt
         | show
@@ -8514,14 +8528,76 @@ opt_ignore_leaves:
 */
 
 
+/* BEGIN DBXP MODIFICATION */
+/* Reason for Modification: */
+/* This section captures (parses) the SELECT DBXP statement */
+
+dbxp_select:
+         DBXP_SELECT_SYM DBXP_select_options DBXP_select_item_list
+                 DBXP_select_from
+         {
+             LEX *lex= Lex;
+           lex->sql_command = SQLCOM_DBXP_SELECT;
+         }
+         ;
+
+/* END DBXP MODIFICATION */
+
 select:
-          select_init
+         select_init
           {
             LEX *lex= Lex;
             lex->sql_command= SQLCOM_SELECT;
           }
         ;
 
+/* BEGIN DBXP MODIFICATION */
+/* Reason for Modification: */
+/* This section captures (parses) the sub parts of the SELECT DBXP statement */
+
+DBXP_select_options:
+   /* empty */
+   | DISTINCT
+   {
+     Select->options|= SELECT_DISTINCT;
+   }
+  ;
+
+DBXP_select_from:
+  FROM join_table_list DBXP_where_clause {};
+
+DBXP_select_item_list:
+  /* empty */
+  | DBXP_select_item_list ',' select_item
+  | select_item
+  | '*'
+    {
+      THD *thd= YYTHD;
+      Item *item= new (thd->mem_root)
+                    Item_field(&thd->lex->current_select->context,
+                               NULL, NULL, "*");
+      if (item == NULL)
+        MYSQL_YYABORT;
+      if (add_item_to_list(thd, item))
+        MYSQL_YYABORT;
+      (thd->lex->current_select->with_wild)++;
+    };
+
+DBXP_where_clause:
+  /* empty */  { Select->where= 0; }
+   | WHERE expr
+    {
+      SELECT_LEX *select= Select;
+      select->where= $2;
+      if ($2)
+        $2->top_level_item();
+    }
+    ;
+
+
+/* END DBXP MODIFICATION */
+
+
 /* Need select_init2 for subselects. */
 select_init:
           SELECT_SYM select_init2
@@ -12631,7 +12707,21 @@ wild_and_where:
 
 /* A Oracle compatible synonym for show */
 describe:
-          describe_command table_ident
+/* BEGIN DBXP MODIFICATION */
+/* Reason for Modification: */
+/* This section captures (parses) the EXPLAIN (DESCRIBE) DBXP statements */
+
+  describe_command DBXP_SELECT_SYM DBXP_select_options DBXP_select_item_list
+                 DBXP_select_from
+  {
+          LEX *lex= Lex;
+          lex->sql_command = SQLCOM_DBXP_EXPLAIN_SELECT;
+          lex->select_lex.db= 0;
+          lex->verbose= 0;
+  }
+
+/* END DBXP MODIFICATION */
+         | describe_command table_ident
           {
             LEX *lex= Lex;
             mysql_init_select(lex);

